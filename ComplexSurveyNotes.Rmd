---
title: "Complex Survey Notes"
author: "Adam Peterson"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
bibliography: surveybib.bib
editor_options: 
  markdown: 
    wrap: 80
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
library(haven)
library(gt)
library(tidyverse)
library(stringr)
library(srvyr)
library(survey)
library(patchwork)
library(RSQLite)
library(DiagrammeR)
library(lattice)
library(quantreg)
library(gtsummary)
library(sf)
theme_set(theme_bw() + theme(
  text = element_text(size = 18),
  strip.background = element_blank()
))
```

# Preface

## Overview

What follows is a coded work through of Thomas Lumley's "Complex Surveys: A
Guide to Analysis in R" [@lumley2011complex] and the methods underlying
[design based](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2856970/)
statistics more broadly. This write-up reflects my understanding of the
material with additions made to try and clarify ideas further. These include
simulations, derivations or references that I found helpful in working through
Lumley's material. Most of the datasets that I use throughout these notes are
from Lumley's website for the
[book](https://r-survey.r-forge.r-project.org/survey/).

## Conducting the Sampling itself

It wasn't very long into reading this book that I found that weighted sampling
in R is, unfortunately, not well set-up for complex designs. Further details are
in [this](https://stats.stackexchange.com/q/639211/) stats exchange post. It
would not be possible, for example, to simply use the popular `tidyverse`
package `dplyr`'s function `slice_sample()` to draw a weighted sample from a
population for example with appropriate inclusion probabilities. Instead a
function from the
[`sampling`](https://cran.r-project.org/web/packages/sampling/index.html)
package would have to be used. I use this function below in any setting where a
non-uniform sample with inclusion probabilities is needed.

Its worth further pointing out that the topic of how samples themselves are
drawn is a complicated one its own right and that the functions in the
`sampling` package each have pros and cons according to the target estimand or
question. Drawing samples with replicate weights -- discussed in Chapter 2 -- is
a similarly complex question which I haven't yet resolved to my satisfaction.

# Chapter 1: The Basics

## Design vs. Model

Key to analysis of complex surveys is the idea of studying the design from which
the data are constructed, rather than the data itself. In a traditional survey
setting the data are assumed to be fixed and the probabilities of sampling
different entities are used to derive the desired estimate. These inclusion
probabilities or their inverse, "sampling weights", are used to re-balance the
data so that they more accurately reflect the target population distribution.
Different sampling techniques --- clustering, 2-phase, etc. --- are used to
either decrease the variance of the resulting estimate, the cost associated with
the design or both.

### Horvitz Thompson Estimation

The Horvitz Thompson Estimator (HTE) is the starting point for non-uniform
random estimates. If we observe measure $X_i$ on subject $i$ of a population of
$N$ total subjects the HTE is formulated as follows:

$$
HTE(X) = \sum_{i=1}^{N} \frac{1}{\pi_i}X_i, \tag{1.1}
$$

which is an unbiased estimator as shown in the [Chapter 1 Appendix].

The variance of this estimate is then

$$
V[HTE(X)] = \sum_{i,j} \left ( \frac{X_i X_j}{\pi_{ij}} - 
\frac{X_i}{\pi_i} \frac{X_j}{\pi_j} \right ), \tag{1.2}
$$

which follows from the Bernoulli covariance using indicator variables $R_i=1$ if
individual $i$ is in the sample, $R_i=0$ otherwise. A proof is provided in the
[Questions From Chapter 1].

### Design And Misspecification Effects

[@kish1965survey] defined the notion of a *design effect* as the ratio of a
variance of an estimate in a complex sample to the variance of the same estimate
in a simple random sample (SRS). The motivation for this entity being that it
can guide researchers in terms of how much sample size they may need; If the
sample size for a given level of precision is known for a simple random sample,
the sample size for a complex design can be obtained by multiplying by the
design effect.

While larger sample sizes may be necessary to maintain the same level of
variance as a SRS, the more complex may still be more justified because of the
lower cost associated. See [@meng2018statistical] for an example of where design
effects are used in a modern statistical setting by comparing competing
estimators.

### Other preliminary items

From this point Lumley works through an introduction to the datasets used in the
book and the idea that we'll often be taking samples from datasets where we know
the "true" population and computing estimates from there. This isn't always the
case and there may some subtlety worth discussing how to interpret results once
we get into topics like regression, but for the most part his description makes
sense.

One thing I found lacking in this introductory section is the motivation for why
we might take non-uniform samples. It isn't until Chapter 3 that Lumley
discusses probability proportional to size (PPS) sampling, but this is very
often the reason why a non-uniform sample is used.

If we have some measure that is right skewed in our population of interest and
we'd like to estimate the mean, we could take a SRS to estimate the mean but the
variance on that item would be lower than if we sampled proportional to the
right skew measure itself. I'll demonstrate with the following quick example,
suppose we want to measure the income of a population. Incomes are often right
skewed, but we can get a lower variance estimate if we take a weighted sample.

I generate a right skewed population and visualize the distribution.

```{r pps_sample_setup}
population <- tibble(
  id = 1:1E3,
  income = 5E4 * rlnorm(1E3, meanlog = 0, sdlog = 0.5)
)
population %>%
  ggplot(aes(x = income)) +
  geom_histogram() +
  geom_vline(aes(xintercept = mean(income)), linetype = 2, color = "red") +
  ggtitle("Simulated Income Distribution") +
  xlab("Income (USD)")
```

Here I'll take a uniform and weighted sample of size 50. Note that the
differences in the samples are subtle. They might not look all that different on
visual inspection.

```{r pps_draw}
uniform_sample <- population %>%
  slice_sample(n = 50) %>%
  transmute(
    income = income,
    method = "uniform",
    pi = 50 / 1E3
  )

weighted_sample <- population %>%
  mutate(
    pi = sampling::inclusionprobabilities(floor(population$income), 50),
    in_weighted_sample = sampling::UPbrewer(pi) == 1
  ) %>%
  filter(in_weighted_sample) %>%
  transmute(
    income = income,
    pi = pi,
    method = "weighted"
  )

rbind(
  uniform_sample,
  weighted_sample
) %>%
  ggplot(aes(x = income, fill = method)) +
  geom_histogram() +
  ggtitle("Sample Comparisons") +
  xlab("Income (USD)") +
  theme(legend.title = element_blank(), legend.position = "top")
```

Finally I'll estimate the population mean from both samples and include the
design effect calculation in the weighted sample estimate.

```{r pps_estimate}
uniform_sample %>%
  as_survey_design() %>%
  summarize(
    mean_income = survey_mean(income)
  )
```

```{r}
weighted_sample %>%
  as_survey_design(probs = pi) %>%
  summarize(mean_income = survey_mean(income, deff = TRUE))
```

We see that the weighted estimate standard error is not quite half the uniform
estimate. Accordingly the design effect for the weighted sample is less than 1.

## Questions From Chapter 1

1.1-1.2 Don't make sense to reproduce here.

1.3 Each visit to the front page of a newspaper's website has (independently) a
1/1000 chance of resulting in a questionnaire on voting intentions in a
forthcoming election. Assuming that everyone who is given the questionnaire
responds, why are the results not a probability sample of

-   Voters?
-   Readers of the newspaper?
-   Readers of the newspaper's online version?

Lumley lists 4 properties needed for a sample to be considered a probability
sample.

1.  Every individual (unit of analysis) in the population must have a non-zero
    probability of ending up in the sample ($\pi_i>0 \forall i$)

2.  $\pi_i$ must be known for every individual who does end up in the sample.

3.  Every pair of individuals in the sample must have a non-zero probability of
    both ending up in the sample ($\pi_{i,j} \forall i, j$)

4.  The probability $\pi_{i,j}$ must be known for every pair that does end up in
    the sample.

1 is not guaranteed when considering voters --- there are voters who don't read
the paper who have will have $\pi_i = 0$ --- or the broader heading of "readers"
of the newspaper - since those who only read the physical paper will have a
\$\pi\_i = 0 \$. For "readers of the newspaper's online version" the sample
would only be a probability sample if the time window was further specified, as
there could be online readers who do not visit during the survey window, and
would thus be assigned a $\pi_i=0$.

1.4 You are conducting a survey that will estimate the proportion of women who
used anti-malarial insecticide-treated bed nets every night during their last
pregnancy. With a simple random sample you would need to recruit 50 women in any
sub-population where you wanted a standard error of less than 5 percentage
points in the estimate. You are using a sampling design that has given design
effects of 2-3 for proportions in previous studies in similar areas.

-   Will you need a larger or smaller sample size than 50 for a subpopulation to
    get the desired precision?

Larger, a design effect $>1$ indicates that the variance is larger in the
complex design with the same sample size - consequently the sample size will
need to be increased to maintain the same level of precision.

-   Approximately what sample size will you need to get the desired precision?

100 - 150. Derived from multiplying 50 by 2 and 3.

1.5 Systematic sampling involves taking a list of the population and choosing,
for example, every 100th entry in the list.

a)  Which of the necessary properties of a probability sample does this have?

Items 2-4 from the list enumerated above. The only condition that is not
satisfied is that not every item has a nonzero probability of being chosen.

b)  For systematic sampling with a random start, the procedure would be to
    choose a random starting point from 1, 2, ..., 1000 and then take every
    100th entry starting at the random point. Which of the necessary properties
    of a probability sample does this procedure have?

This satisfies all items from the above list.

c)  For systematic sampling with multiple random starts we might choose 5 random
    starting points in 1, 2, ....., 5000 and then take every 500th entry
    starting from each of the 5 random points. Which of the necessary properties
    of a probability sample does this procedure have?

Again, this satisfies all items from the above list.

d)  If the list were shuffled into a random order before a systematic sample was
    taken, which of the properties would the procedure have.

Again, all of them. The key is adding the *known* randomness and not excluding
any items from selection.

e)  Treating a systematic sample as if it were a simple random sample often
    gives good results. Why would this be true?

This would be because the items are not ordered in any particular fashion prior
to taking the "systematic sampling". In this setting a systematic sample is
equivalent to a simple random sample.

1.6 Why must all the sampling probabilities be non-zero to get a valid
population estimate?

If any of the sampling probabilities are zero, that would introduce bias in
shifting the estimate away from the portion of the population that would
*always* be unobserved under repeated sampling.

1.7 Why must all the pairwise probabilities be non-zero to get a valid
uncertainty estimate.

This is basically a second order statement equivalent to the previous. If any
pair is unable to be observed together that is a form of selection bias that
would shift the sample estimate away from the true population value.

1.8 A probability design assumes that people who are sampled will actually be
included in the sample, rather than refusing. Look up the response rates for the
most recent year of BRFSS and NHANES.

Lumley is highlighting the fact that even though we set up samples thinking
that every sample will be observed that is rarely the case. Looking at 
just the most recent NHANES [data](https://www.cdc.gov/nchs/hus/sources-definitions/nhanes.htm#sample-size-response-rate) I see response rates at ~ 78% for the unweighted, 6-year household survey.

1.9 In a telephone study using random digit dialing, telephone numbers are
sampled with equal probability from a list. When a household is recruited, why
is it necessary to ask how many telephones are in the household, and what should
be done with this information in computing the weights.

It is necessary to ask how many telephones are in the household to downweight
the *a priori* sampling probability accordingly because every additional
telephone line increases the odds that a given house is sampled. For example in
a simple population with two houses, where house one has 5 telephones and house
two has 2 telephones, and we're looking to take a $n=1$ sample, but we don't
know the number of telephones a priori, house one has a $\frac{5}{7}$
probability of being sampled. If that is the house that is chosen its weight
needs to go from 2 to $\frac{5}{7}$ to better reflect its sampling probability.
In a real sample this would be corrected relative to all the other households
number of telephones or perhaps a population average of the number of
telephones.

1.10

Derive the Horvitz Thompson variance estimator for the total as follows.

a)  Write $R_i = 1$ if individual $i$ is in the sample, $R_i=0$ otherwise. Show
    that $V[R_i] = \pi_i(1-\pi_i)$ and that
    $Cov[R_i,R_j]=\pi_{ij} - \pi_i\pi_j$.

This follows in a straightforward fashion from the assumption that $R_i$ is
distributed according to the bernoulli distribution and $R_i \perp R_j$. This is
an accurate model for sampling with replacement, or sampling from large
populations with small sample sizes without replacement, but less true for small
sample sizes without replacement.

b)  Show that the variance of the Horvitz Thompson estimator is:

$$
V[\hat{T}_{HT}] = \sum_{i=1}^{N}\sum_{j=1}^{N} \check{x}_i\check{x}_j(\pi_{ij} - \pi_i \pi_j)
$$ We have, $$
\hat{T}_{HT} := \sum_{i=1}^{N} \frac{X_i I(X_i \in {S})}{\pi_i} \\
V[\hat{T}_{HT}] = V\left[\sum_{i=1}^{N}\frac{X_i I(X_i \in {S})}{\pi_i} \right] \\ 
=\sum_{i=1}^{N}\sum_{j=1}^{N} Cov\left[\frac{X_i I(i \in {S})}{\pi_i},
\frac{X_j I(j \in {S})}{\pi_j}\right]\\
= \sum_{i=1}^{N}\sum_{j=1}^{N} \frac{X_i}{\pi_i}\frac{X_j}{\pi_j}Cov(I(i \in 
{S}),I(j \in {S})) \\
= \sum_{i=1}^{N}\sum_{j=1}^{N} \frac{X_i}{\pi_i}\frac{X_j}{\pi_j} (\pi_{ij} - 
\pi_i \pi_j)
$$

which is equivalent to the above, where $\check{x_i} = \frac{X_i}{\pi_i}$.

c)  Show that an unbiased estimator of the variance is $$
    \hat{V}[\hat{T}_{HT}] = \sum_{i=1}^{N}\sum_{j=1}^{N} 
    \frac{R_i R_j}{\pi_{ij}}\check{x_i}\check{x_j}(\pi_{ij} - \pi_i \pi_j)
    $$

To show the expression above is unbiased for $\hat{V}[\hat{T}_{HT}]$ we must
show that $E\left [\hat{V}[\hat{T}_{HT}] \right] = V[\hat{T}_{HT}]$ $$
E \left [\hat{V}[\hat{T}_{HT} ] \right] = E \left[\sum_{i=1}^{N}\sum_{j=1}^{N} \frac{R_iR_j}{\pi_{ij}} \check{x}_i \check{x}_j(\pi_{ij} - \pi_i\pi_j) \right] \\ 
= \sum_{i=1}^{N} \sum_{j=1}^{N} \frac{E[R_iR_j]}{\pi_{ij}} \check{x}_i \check{x}_j (\pi_{ij} - \pi_i \pi_j) \\
= \sum_{i=1}^{N} \sum_{j=1}^{N} \frac{\pi_{ij}}{\pi_{ij}} \check{x}_i\check{x}_j(\pi_{ij} - \pi_i \pi_j)  \\
= \sum_{i=1}^{N} \sum_{j=1}^{N}  \check{x}_i\check{x}_j(\pi_{ij} - \pi_i \pi_j)  \\
\blacksquare
$$

d)  Show that the previous expression simplifies to equation 1.2

$$
\sum_{i=1}^{N} \sum_{j=1}^{N} \frac{R_iR_jx_ix_j}{\pi_{ij}\pi_i\pi_j}(\pi_{ij} - \pi_i \pi_j) \\
=
\sum_{i=1}^{n} \sum_{j=1}^{n} \frac{x_ix_j}{\pi_{ij}\pi_i\pi_j}(\pi_{ij} - \pi_i \pi_j) \\
= 
\sum_{i=1}^{n} \sum_{j=1}^{n} x_i x_j(\frac{1}{\pi_i \pi_j} - \frac{1}{\pi_{ij}}) \\
= 
\sum_{i=1}^{n} \sum_{j=1}^{n} \frac{x_ix_j}{\pi_i \pi_j}  - \frac{x_i x_j}{\pi_{ij}}\
$$

I'm not sure how the signs switch on the last line to reproduce expression 1.2

1.11 Another popular way to write the Horvitz-Thompson variance estimator is

$$
\hat{V}[\hat{T}_{HT}] = \sum_{i=1}^{n} x_i^{2} \frac{1-\pi_i}{\pi_i^2} + 
\sum_{i\neq j}x_ix_j\frac{\pi_{ij} - \pi_i \pi_j}{\pi_i\pi_j\pi_{ij}}
$$

Show that this is equivalent to equation 1.2

We need to show that the above is equivalent to
$$
\sum_{i,j} \frac{X_iX_j}{\pi_{ij}} - \frac{X_i}{\pi_i}\frac{X_j}{\pi_j}
$$

First we fix $i \neq j$ in the above expression and we find
$$
\sum_{i\neq j} \frac{X_iX_j}{\pi_{ij}} - \frac{X_i}{\pi_i}\frac{X_j}{\pi_j} = 
\sum_{i\neq j} X_iX_j(\frac{1}{\pi_{ij}} - \frac{1}{\pi_i} \frac{1}{\pi_j}) \\
= \sum_{i \neq j} X_iX_j(\frac{\pi_i \pi_j - \pi_{ij}}{\pi_{ij}\pi_i\pi_j})
$$

which is the latter part in the desired expression save for a sign, which again 
I must be missing somehow or is an error in the book. 

Now we take $i=j$ and return to expression 1.2 in which we have,

$$
\sum_{i=j} \frac{X_i X_j}{\pi_{ij}} - \frac{X_i}{\pi_i} \frac{X_j}{\pi_j} \\ 
= \sum_{i=j} \frac{X_i^2}{\pi_{ii}} - \frac{X_i}{\pi_i} \frac{X_i}{\pi_i} \\
= \sum_{i=j} X_i^2 (\frac{1}{\pi_{ii}} - \frac{1}{\pi_i^2} ) \\
= \sum_{i=j} X_i^2 (\frac{\pi_i^2 - \pi_{ii}}{\pi_i^2 \pi_{ii}})
$$
Clearly we have to formulate $\pi_{ii}$ in terms of $\pi_i$ but isn't immediately
clear to me how to do so. We know that for the two terms to be equal we must have

$$
\frac{\pi_i^2 - \pi_{ii}}{\pi_i^2 \pi_{ii}} = \frac{1 - \pi_i^2}{\pi_i^2}  \\
\iff \\
\pi_{ii} = \frac{\pi_i^2}{2- \pi_i^2}
$$
Which I suppose we'll take to be the expression of a co-inclusion probability of
an entity sampled with itself (this must assume sampling with replacement) for
this expression to be true.

## Chapter 1 Appendix

The HTE is an unbiased estimator of the population total - I reproduce the
expression from above, but now make explicit the indicator variables that
express which observations are included in our sample, $S$.

$$
HTE := \sum_{i=1}^{N} \frac{X_i I(X_i \in S)}{\pi_i} \\
E[HTE] = E\left [\sum_n \frac{X_i I(X_i \in S)}{\pi_i} \right ] \\
= \sum_n E \left [\frac{X_iI(X_i \in S)}{\pi_i} \right ] \\
= \sum_n \frac{X_iE[I(X_i \in S)]}{\pi_i} \\ 
= \sum_n \frac{X_i \pi_i}{\pi_i} = \sum_n X_i
$$

# Chapter 2: Simple and Stratified Sampling

## Starting from Simple Random Samples

When dealing with a sample of size $n$ from a population of size $N$ the HTE of
the total value of $X_i$ in the population can be written as

$$
\begin{equation}
HTE(X) = \hat{T_X} =  \sum_{i=1}^{n} \frac{X_i}{\pi_i}.
\end{equation}
$$

For a simple random sample, the variance can be more explicitly written as

$$
\begin{equation}
V[\hat{T_X}] = \frac{N-n}{N} \times N^{2} \times \frac{V[X]}{n},
\end{equation}
$$

where $\frac{N-n}{N}$ is the finite population correction factor. This factor is
[derived](https://stats.stackexchange.com/questions/5158/explanation-of-finite-population-correction-factor)
from the hypergeometric distribution and explains the reduction in uncertainty
that follows from sampling a large portion of the population. Consequently, if
the sample is taken with replacement --- the same individual or unit has the
possibility to be sampled twice --- this term is no longer relevant. It should
be noted that sampling with replacement is not usually used however, but
sometimes this language is used to refer to the fact that the finite correction
factor may not be used.

The second term, $N^2$, rescales the estimate from the mean to the total, while
the final term is simply the scaled variance of $X$.

A point worth deliberating on, that Lumley notes as well, is that while the
above equations suggest that a larger sample size is always better that is not
always the case in reality. Non-response bias or the cost of surveys can
dramatically diminish the *quality* of the dataset, even if the size is large. I
state this is worth deliberating on because it is a matter of increasing
importance in the world of "Big Data" - where it can be easy to delude oneself
with confidence in their estimates because their sample is large, even when the
sample is not well designed. See [@meng2018statistical] for a larger discussion
of this topic.

It follows from the above that the HTE for the population size is defined as
$\hat{N} = \sum_{i=1}^{n} \frac{1}{\pi_i}$. This holds true in the case where,
as here $\pi_i = \frac{n}{N}$, a bit trivial, but also in those where $\pi_i$
may be defined differently.

## Confidence Intervals

The sampling distribution for the estimates --- typically sample means and sums
--- across "repeated surveys" is Normal by the Central Limit Theorem, so the
typical $\bar{x} \pm 1.96 \sqrt{\frac{\sigma^2_X}{n}}$, expression is used to
calculate a 95% confidence interval. Lumley offers the following example from
the California Academic Performance Index (API)
[dataset](https://www.cde.ca.gov/re/pr/api.asp) to illustrate this idea.

```{r clt_demo, fig.width = 14, fig.height = 8, cache = TRUE}
data(api)
mn_enroll <- mean(apipop$enroll, na.rm = TRUE)
p1 <- apipop %>%
  ggplot(aes(x = enroll)) +
  geom_histogram() +
  xlab("Student Enrollment") +
  geom_vline(xintercept = mn_enroll, linetype = 2, color = "red") +
  ggtitle("Distribution of School Enrollment")
p2 <- replicate(n = 1000, {
  apipop %>%
    sample_n(200) %>%
    pull(enroll) %>%
    mean(., na.rm = TRUE)
})
mn_sample_mn <- mean(p2)
p2 <- tibble(sample_ix = 1:1000, sample_mean = p2) %>%
  ggplot(aes(x = sample_mean)) +
  geom_histogram() +
  xlab("Student Enrollment Averages") +
  geom_vline(
    xintercept = mn_sample_mn,
    linetype = 2, color = "red"
  ) +
  ggtitle("Distribution of Sample Means")
p1 + p2
```

## Complex Sample Data in R

What follows is a work-up of basic survey estimates using the California API
dataset composed of student standardized test scores. I'll work through the code
once using the `survey` package and a second time using the `srvyr` package,
which has a [tidyverse](https://www.tidyverse.org/) friendly API.

Much of the computational work in this book begins with creating a design
object, from which weights and other information can then be drawn on for any
number/type of estimates.

For example, we create a basic design object below, where we look at a classic
simple random sample (SRS) of the schools in the API dataset. Let's take a look
at the dataset first.

```{r apisrs_view}
dplyr::as_tibble(apisrs)
```

In the code below `fpc` stands for the aforementioned finite population
correction factor and `id=~1` designates the unit of analysis as each individual
row in the dataset.

```{r design_intro}
srs_design <- svydesign(id = ~1, fpc = ~fpc, data = apisrs)
srs_design
```

In order to calculate the mean enrollment based on this sample the,
appropriately named, `svymean` function can be used.

```{r srs_svymean}
svymean(~enroll, srs_design)
```

This is the same as the typical computation - which makes sense, this is a SRS!

```{r srs_mean}
c(
  "Mean" = mean(apisrs$enroll),
  "SE" = sqrt(var(apisrs$enroll) / nrow(apisrs))
)
```

Instead of specifying the finite population correction factor, the sampling
weights could be used - since this is a SRS, all the weights should be the same.

```{r srs_weights}
as_tibble(apisrs) %>% distinct(pw)
```

```{r nofpc_design}
nofpc <- svydesign(id = ~1, weights = ~pw, data = apisrs)
nofpc
```

Use `svytotal` to calculate the estimate of the total across all schools, note
that the standard error will be different between the two designs because of the
lack of fpc.

```{r nofpc_svytotal}
svytotal(~enroll, nofpc)
```

```{r srs_svytotal}
svytotal(~enroll, srs_design)
```

Totals across groups can be calculated using the `~` notation with a categorical
variable.

```{r total_cats}
svytotal(~stype, srs_design)
```

`svycontrast` can be used to calculate the difference or addition of two
different estimates - below we estimate the difference in the 2000 and 1999
scores based on the SRS design.

```{r srs_contrast}
svycontrast(svymean(~ api00 + api99, srs_design), quote(api00 - api99))
```

### Now again with the `srvyr` package

```{r srvyr_demo}
dstrata <- apisrs %>%
  as_survey_design(fpc = fpc)
dstrata %>%
  mutate(api_diff = api00 - api99) %>%
  summarise(
    enroll_total = survey_total(enroll, vartype = "ci"),
    api_diff = survey_mean(api_diff, vartype = "ci")
  ) %>%
  gt()
```

## Stratified Sampling

Simple random samples are not often used in complex surveys because there is a
justified concern that some strata (e.g. racial ethnic group, age group, etc.)
may be underrepresented in the sample if a simple random sample were used.
Similarly, complex designs can give the same precision at a lower cost.
Consequently, a sample may be constructed so that some units are guaranteed to
be included within a given strata - improving the resulting variance. When this
is a simple random sample, the HTE and variance of the total population is
simply the sum of the strata specific estimates;
$\hat{T}_{HT} = \sum_{s=1}^{S} \hat{T}^{s}_X$, where there are $S$ strata within
the population.

For example, in the `apistrat` data set a stratified random sample of 200
schools is recorded such that schools are sampled randomly within school type (
elementary, middle school or high school).

In the code below we can designate the strata using the categorical variable
`stype`, which denotes each of the school type as strata.

```{r strat_design}
strat_design <- svydesign(
  id = ~1,
  strata = ~stype,
  fpc = ~fpc,
  data = apistrat
)
strat_design
```

```{r strat_total}
svytotal(~enroll, strat_design)
```

```{r strat_mean}
svymean(~enroll, strat_design)
```

```{r strat_cat_totals}
svytotal(~stype, strat_design)
```

Note that are standard errors are 0 for the within strata estimates because if
we have strata information on each member of the population, then we know the
strata counts without any uncertainty.

Several points worth noting about stratified samples before moving on.

-   Stratified samples get their power from "conditioning" on the strata
    information that explain some of the variability in the measure.

-   Whereas a SRS might have a chance of leaving out an elementary or middle
    school, and leaving a higher estimate of enrollment, because of a higher
    number of highschools in the sample, keeping a fixed number of samples
    within each strata removes this problem.

-   Stratified analysis may also refer to something entirely different from what
    we're discussing here --- where a subgroup has some model or estimate fit
    only on that subgroup's data exclusively.

### Now again with the `srvyr` package

```{r srvyr_strat}
srvyr_strat_design <- apistrat %>%
  as_survey_design(
    strata = stype,
    fpc = fpc
  )
srvyr_strat_design
```

```{r srvyr_strat_totals}
srvyr_strat_design %>%
  summarise(
    enroll_total = survey_total(enroll),
    enroll_mean = survey_mean(enroll)
  ) %>%
  gt()
```

```{r srvyr_strat_counts}
srvyr_strat_design %>%
  group_by(stype) %>%
  survey_count()
```

## Replicate Weights

Replicate weights exploit sub-sampling to derive more generalizable statistics
than sampling weights. This is particularly useful when estimating a
"nonparametric" statistic like the median or a quantile which doesn't have an
easily derived variance.

For a basic idea of why this works, Lumley notes that one could estimate the
variance of a total by using two independent half samples estimating the same
total, i.e. if $\hat{T}_A$ and $\hat{T}_B$ are both from two independent half
samples estimating $\hat{T}$ then the variance of the difference of the two half
samples is proportional to the variance of the original total:

$$
E\left[ (\hat{T}_A - \hat{T}_B)^2 \right] = 2 V[\hat{T}_A] = 4 V[\hat{T}].
$$

There are multiple ways one might set up these splits that are more efficient
than the straightforward "half" sample described above - Lumley discusses 3
variants briefly:

1.  [Balanced Repeated
    Replication](https://en.wikipedia.org/wiki/Balanced_repeated_replication)
    (BRR) Based on the work of [@mccarthy1966replication].

-   [@judkins1990fay], extends BRR to handle issues with sparse signals and
    small samples.

2.  [Jackknife](https://en.wikipedia.org/wiki/Jackknife_resampling)

-   Because BRR and Fay's method is difficult with other designs using
    overlapping subsamples, Jackknife and the bootstrap are intended to be more
    flexible.

3.  [Bootstrap](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))

-   This is the method I'm most familiar with, outside of complex designs.
-   Lumley states that using the Bootstrap in this setting involves taking a
    sample (with replacement) of observations or clusters and multiplying the
    sampling weight by the number of times the observation appears in the
    sample.

Each of these ideas relies on the fundamental idea that we can calculate the
variance of our statistic of interest by using --- sometimes carefully chosen
--- subsamples of our original sample to calculate our statistic of interest and
more importantly, the variance of that statistic. Lumley's use of the equation
above gives the basic idea but I believe the more rigorous justification appeals
to theory involving [empiricial distribution
functions](https://en.wikipedia.org/wiki/Empirical_distribution_function), as
much of the theory underlying these ideas relies on getting a good estimate of
the empirical distribution.

It isn't explicitly clear which of these techniques is most popular currently,
but my guess would be that the bootstrap is the most used. This also happens to
be the method that Lumley has provided the most citations for in the text. I've
also [run into](https://github.com/walkerke/tidycensus/issues/552) cases where
the US Census IPUMS data [uses](https://usa.ipums.org/usa/repwt.shtml#q50)
[successive difference
weights](http://www.asasrms.org/Proceedings/y2011/Files/302108_67867.pdf).

All this to say that replicate weights are powerful for producing
"non-parametric" estimates, like quantiles and so on, and different weighting
techniques may be more or less appropriate depending on the design and data
involved.

### Replicate Weights in R

Lumley first demonstrates how to setup a survey design object when the weights
are already provided. I've had trouble accessing the 2005 California Health
Interview Survey
[data](http://healthpolicy.ucla.edu/chis/data/Pages/GetCHISData.aspx) on my own
but he thankfully provides a link to the data on his
[website](https://r-survey.r-forge.r-project.org/svybook/).

```{r rep_weights_setup}
chis_adult <- as.data.frame(read_dta("Data/ADULT.dta")) %>%
  # have to convert labeled numerics to regular numerics for
  # computation in survey package.
  mutate(
    bmi_p = as.numeric(bmi_p),
    srsex = factor(srsex, labels = c("MALE", "FEMALE")),
    racehpr = factor(racehpr, labels = c(
      "LATINO", "PACIFIC ISLANDER",
      "AMERICAN INDIAN/ALASKAN NATIVE",
      "ASIAN", "AFRICAN AMERICAN",
      "WHITE",
      "OTHER SINGLE/MULTIPLE RACE"
    ))
  )
chis <- svrepdesign(
  variables = chis_adult[, 1:418],
  repweights = chis_adult[, 420:499],
  weights = chis_adult[, 419, drop = TRUE],
  ## combined.weights specifies that the replicate weights
  ## include the sampling weights
  combined.weights = TRUE,
  type = "other", scale = 1, rscales = 1
)
chis
```

When *creating* replicate weights in R one specifies a replicate type to the
`type` argument.

```{r bootstrap_design}
boot_design <- as.svrepdesign(strat_design,
  type = "bootstrap",
  replicates = 100
)
boot_design
```

By default, the `as.svrepdesign()` function assumes the replicate weights are
jackknife replicates.

```{r jackknife_design}
## jackknife is the default
jk_design <- as.svrepdesign(strat_design)
jk_design
```

Once the design object is created the mean of a variable can computed
equivalently as before using the `svymean()` function. We'll compare the
bootstrap and jackknife estimates, noting that the bootstrap has a higher
standard error than the jackknife.

```{r bootstrap_mean}
svymean(~enroll, boot_design)
```

```{r jckknife_mean}
svymean(~enroll, jk_design)
```

Of course, part of the motivation in using replicate weights is that you're able
to estimate standard errors for non-trivial estimands, especially those that may
not be implemented in the `survey` package. Lumley demonstrates this using a
sample from the [National Wilms Tumor Study
Cohort](https://pubmed.ncbi.nlm.nih.gov/18027087/), in order to estimate the
five year survival probability via a
[Kaplan-Meier](https://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator)
Estimator.

```{r ntwsco_view}
library(addhazard)
nwtsco <- as_tibble(nwtsco)
head(nwtsco)
```

```{r ntwsco_analysis}
cases <- nwtsco %>% filter(relaps == 1)
cases <- cases %>% mutate(wt = 1)
ctrls <- nwtsco %>% filter(relaps == 0)
ctrls <- ctrls %>%
  mutate(wt = 10) %>%
  sample_n(325)
ntw_sample <- rbind(cases, ctrls)

fivesurv <- function(time, status, w) {
  scurve <- survfit(Surv(time, status) ~ 1, weights = w)
  ## minimum probability that corresponds to a survival time > 5 years
  return(scurve$surv[min(which(scurve$time > 5))])
}

des <- svydesign(id = ~1, strata = ~relaps, weights = ~wt, data = ntw_sample)
jkdes <- as.svrepdesign(des)
withReplicates(jkdes, quote(fivesurv(trel, relaps, .weights)))
```

The estimated five year survival probability of 84% (95% CI: 84%,85%) uses the
`fivesurv` function which computes the kaplan meier estimate of five year
survival probability fora given time status and weight. The `withReplicates`
function then re-estimates this statistic using each set of replicates and
calculates the standard error from the variability of these estimates.

Its worth noting that this is the standard error for estimating the five year
survival in the NWTS cohort, not the hypothetical superpopulation of all
children with Wilms' tumor.

### Now again with the `srvyr` package

```{r}
boot_design <- as_survey_rep(strat_design,
  type = "bootstrap",
  replicates = 100
)
boot_design
```

```{r srvyr_bootdesign_mean}
boot_design %>% summarise(Mean = survey_mean(enroll))
```

It's not clear or straightforward to me from reading the `srvyr`
[docs](http://gdfe.co/srvyr/articles/extending-srvyr.html) how to estimate the
weighted survival function probability --- I may return to this later.

### Final Notes on Replicate Weights

Lumley finishes this section by noting that the bootstrap typically works better
when all the strata are large. While a strata correction is available it is
likely not correct for small or unequal strata.

Separately, Lumley note that both the jackknife and bootstrap can incorporate
finite population correction factors.

Finally, the BRR designs implemented in the `survey` package will use at most
excess 4 replicate splits for $K < 180$ and at most 5% when $K > 100$. It is not
clear to me from the reading, which is more likely to be used for
$100 < K < 180$.

## Other population summaries

While population means, totals, and differences are typically easy to estimate
via the horvitz thompson estimator there are other population statistics such as
the median or regression estimates that are more complex. These require using
the replicate weights described in the previous [section](#Replicate%20Weights)
or making certain linearization / interpolation assumptions which may or may not
influence the resulting estimate.

### Quantiles

Estimation of quantiles involves estimating arbitary points along the
[cumulative distribution
function](https://en.wikipedia.org/wiki/Cumulative_distribution_function)(cdf).
For example, the 90th percentile has 90% of the estimated population size below
it and 10% above. In this case, for cdf $F_X(x)$, we want to estimate
$x: F_X(x) = 0.9$. However, estimating the cdf presents some technical
difficulties in that the [empirical cumulative distribution
function](https://en.wikipedia.org/wiki/Empirical_distribution_function) (ecdf),
is not typically a "smooth" estimate for any given $x$ --- as the estimate is
highly dependent upon the sample. Consequently, Lumley's function,
`svyquantile()` interpolates linearly between two adjacent observations when the
quantile is not uniquely defined.

```{r sample_ecdf, fig.cap="Empirical Cumulative Distribution Function - note the jumps at distinctive points along the x-axis."}
samp <- rnorm(20)
plot(ecdf(samp))
```

Confidence intervals are constructed similarly, using the ecdf, though it should
be noted that estimating extreme quantiles poses difficulties because of the low
density values in the area.

A first calculation to demonstrate this using replicate weights with the CA
health interview study, estimating different quantiles of BMI.

```{r quantile_rep_estimate}
svyquantile(~bmi_p, design = chis, quantiles = c(0.25, 0.5, 0.75))
```

The same thing can be done with the stratified design. Here the uncertainty is
computed via the estimates of the ecdf and finding the pointwise confidence
interval for different points along the curve.

```{r quantile_wt_estimate}
svyquantile(~api00,
  design = strat_design, quantiles = c(0.25, 0.5, 0.75),
  ci = TRUE
)
```

You can see how to construct the same estimate below using the `srvyr` package.

```{r srvyr_q_wt_estimate}
srvyr_strat_design %>%
  summarize(quantiles = survey_quantile(api00, quantiles = c(0.25, 0.5, 0.75)))
```

### Contingency Tables

Lumley's main points in this section focus on the complications in
interpretation of typical contingency table tests of association in a design
based setting. Specifically, he points out that it is not obvious how the null
distribution should be generated without making some kind of modeling
assumptions. Quoting from the book (text in parentheses from me):

> For example, if there are 56,181,887 women and 62,710,561 men in a population
> it is not possible for the proportions of men and women who are unemployed to
> be the same, since these population sizes have no common factors. We would
> know without collecting any employment data that the finite-population null
> hypothesis (of equal proportions) was false. A more interesting question is
> whether the finite population could have arisen from a process that had no
> association between the variables: is the difference at the population level
> small enough to have arisen by chance.... A simpler approach is to treat the
> sample as if it came from an infinite superpopulation and simply ignore the
> finite-population corrections in inference.

The super-population approach offers the more interesting approach
philosophically and thus is implemented in the `survey` package. The `svychisq`
function implements a test for no association as the null using a chi-squared
distribution with a correction for the mean and variance. Lumley discusses
various methods for computing the $\chi^2$ statistic in this setting and their
implementations in `svycontrast()`. I'd suggest looking at the function
documentation if that level of detail is needed.

Lumley demonstrates how to call these functions estimating the proportion of
smokers in each insurance status group from the California Health Interview
Survey.

```{r, eval = TRUE}
tab <- svymean(~ interaction(ins, smoking, drop = TRUE), chis)
tab
```

```{r, eval = TRUE}
ftab <- ftable(tab, rownames = list(
  ins = c("Insured", "Uninsured"),
  smoking = c("Current", "Former", "Never")
))
round(ftab * 100, 1)
```

In the output below we see a very small p-value indicating that the data were
unlikely to be generated from a *process* in which smoking and insurance status
were independent.

```{r}
svychisq(~ smoking + ins, chis)
```

### Estimates in Subpopulations

Estimation within subpopulations (also called domain estimation) that are
sampled strata is easy since a stratified sample is composed of random samples
within strata by definition; simply compute the desired statistic within the
given strata using the strata-specific random sample.

When the subpopulation of interest is not a strata, things are more difficult.
While the sampling weights would still be correct for representing any given
observation to the total population --- resulting in an unbiased mean point
estimate --- the co-occurrence probabilities $\pi_{i,j}$ would be incorrect,
because the co-occurrence probabilities are now unknown/random and not fixed by
design. The two (usual) approaches for trying to estimate subpopulation variance
estimates in-spite of these difficulties are
[linearization](https://en.wikipedia.org/wiki/Linearization#:~:text=In%20mathematics%2C%20linearization%20is%20finding,around%20the%20point%20of%20interest.)
and replicate weighting. The computation is straightforward for replicate
weighting since the non-subpopulation entities can simply be discarded in the
computation. For linearization the computation is less straightforward as the
extra entities still have to be included as "0"s in the final computation --
this is according to Lumley's arguments in his Appendix.

Examples below demonstrating this idea estimate the number of teachers with
emergency, `emer`, training amongst California schools using the `api` dataset.

```{r subpop_1}
emerg_high <- subset(strat_design, emer > 20)
emerg_low <- subset(strat_design, emer == 0)
svymean(~ api00 + api99, emerg_high)
```

```{r subpop_2}
svymean(~ api00 + api00, emerg_low)
```

```{r subpop_3}
svytotal(~enroll, emerg_high)
```

```{r subpop_4}
svytotal(~enroll, emerg_low)
```

In general, if replicate weights are available, domain estimation is much
easier.

```{r subpop_5_rwts}
bys <- svyby(~bmi_p, ~ srsex + racehpr, svymean,
  design = chis,
  keep.names = FALSE
)
print(bys, digits = 3)
```

```{r subpop_6_rwts}
# This is the code from the book but it didn't work for me
# because of issues in the survey R package, I reproduce the
# first result using the srvyr package below
# medians <- svyby(~bmi_p, ~ srsex + racehpr, svyquantile,
#   design = chis,
#   covmat = TRUE,
#   quantiles = 0.5
# )
# svycontrast(medians, quote(MALE.LATINO/FEMALE.LATINO))

medians <- chis %>%
  as_survey() %>%
  group_by(srsex, racehpr) %>%
  summarize(Median_BMI = survey_median(bmi_p, vartype = "ci"))

medians
```

## Design of Stratified Samples

How to pick the sample size for each strata? Well it depends on the goals of the
analysis. If the goal is to estimate a total across the whole population, the
formula for the variance of a total can be used to gain insights about optimal
allocation. Since the variance of the total is dependent (via sum) of the strata
specific variances, more sample size would want to be dedicated to more
heterogeneous and/or larger strata.

This general approach means that the sample size for strata $k$, $n_k$ should be
proportional to the population strata size $N_k$ and strata variance
$\sigma^{2}_k$, $n_k \propto \sqrt{N^2_k \sigma^2_k} = N_k \sigma_k$. Lumley
notes that while this expression satisfies some theoretical optimality criteria,
it is often the case that different strata have different costs associated with
their sampling and so the expression can be modified in order to take into
account this cost as follows:

$$
n_k \propto \frac{ N_k \sigma_k}{\sqrt{\text{cost}_k}},
$$

where cost$_k$ is the cost of sampling for strata $k$.

## Questions

1.You are conducting a survey of emergency preparedness at a large HMO, where
you want to estimate what proportion of medical staff would be able to get to
work after an earthquake.

a.) You can either send out a single questionnaire to all staff, or send out a
questionnaire to about 10% of the staff and make follow-up phone calls for those
that don't respond. What are the disadvantages of each approach?

This comes down to a discussion of cost for sampling and what missing data
mechanism may be at play. As a simple starting point, if we were to assume the
resulting data were MCAR and the non response rate was equivalent between both
sampling strategies, the single questionnaire would be preferred because it
would result in a higher overall sample size. These assumptions are probably not
likely however, and we may expect that non-response is associated with other
meaningful factors, by choosing a the follow-up phone call we might minimize
non-response to both reduce bias and improve precision.

Additional relevant concerns would be the possible response or lack of response
of certain strata --- certain physicians, technicians or other kinds of staff's
response would likely be worth knowing yet these groups may be less well
represented in a 10% simple random sample of the population.

b.) You choose to survey just a sample. What would be useful variables to
stratify the sampling, and why?

The aforementioned job title would be useful to stratify on. This would likely
be most useful to conduct within each department. Further, if the HMO has more
than one site or clinic, that would be worth stratifying on as well for
substantive reasons just as much as statistical reasons.

c.) The survey was conducted with just two strata: physicians and other staff.
The HMO has 900 physicians and 9000 other staff. You sample 450 physicians and
450 other staff. What are the sampling probabilities in each stratum?

physician strata sampling probabilities are
$\frac{n}{N_k} = \frac{450}{900} = \frac{1}{2}$, while the "other staff"
probabilities are $\frac{450}{9000} = \frac{1}{20}$

d.) 300 physicians and 150 other staff say they would be able to get to work
after an earthquake. Give unbiased estimates of the proportion in each stratum
and the total proportion.

The physician strata estimate would be $\frac{300}{450} = \frac{2}{3}$. The
staff strata would be $\frac{150}{450} = \frac{1}{3}$ The total proportion would
be $\frac{2 \times 300 + 20 \times 150}{9900}$. This value can be recreated
below with the `survey` package as follows.

```{r strata_q_setup}
df <- tibble(
  id = 1:900,
  job = c(rep("MD", 450), rep("staff", 450)),
  prep = c(rep(1, 300), rep(0, 150), rep(1, 150), rep(0, 300)),
  weights = c(rep(2, 450), rep(20, 450))
)
hmo_design <- svydesign(strata = ~job, ids = ~0, weights = ~weights, data = df)
hmo_design
```

```{r strata_q_answer}
svymean(~prep, hmo_design)
```

e.) How would you explain to the managers that commissioned the study how the
estimate was computed and why it wasn't just the number who said "yes" divided
by the total number surveyed?

We sampled from the total population using the strata because we though these
two groups would respond differently and indeed, they did. Physicians have are
twice as likely to be able to make it to the hospital in the event of an
emergency as general staff. However, physicians make up a much smaller
proportion of the overall hospital workforce and so we need to down weight their
responses, relative to general staff in order to ensure their response reflects
their distribution in the total population, thus the total estimate of the HMO's
emergency preparedness is much closer to the "general" staff's strata estimate
of $\frac{1}{3}$.

2.You are conducting a survey of commuting time and means of transport for a
large university. What variables are likely to be available and useful for
stratifying the sampling?

Probably worth stratifying on "role" at university --- student vs. staff vs.
professor. Each of these have varying amounts of income available and would
likely determine their different means and, consequently, commute time of
getting to campus. It might also be worth stratifying on the department of
employment for staff and professors, as there can be a wide variability in these
measures, again, by department.

3.-4. Skip because of CHIS data issues

5.  In the Academic Performance Index data we saw large gains in precision from
    stratification on school type when estimating mean or total school size, and
    no gain when estimating mean Academic performance Index. Would you expect a
    large or small gain from the following variables: `mobility`, `emer`,
    `meals`, `pcttest`? Compare your expectations with the actual results.

The general principle here, is which of these variables do we expect to have
some association with the school type. The greater association the more the
benefit from stratifying.

6.  For estimating total school enrollment in the Academic Performance Index
    population, what is the optimal allocation of a total sample size of 200
    stratified by school size? Draw a sample with this optimal allocation and
    compare the standard errors to the stratified sample in Figure 2.5 for:
    total enrollment, mean 2000 API, mean `meals`, mean `ell`.

A first point worth noting is that school size is an integer valued variable and
so some grouping will have to be created to define the strata from which schools
are then drawn. One possible option is to define the strata as above and below
the median school enrollment. Since this divides the population exactly in half
the strata are equally sized and the only differentiating factor is the
variability of the enrollment.

```{r}
as_tibble(apipop) %>%
  transmute(
    enroll = enroll,
    strat = if_else(enroll > median(enroll, na.rm = TRUE), "Above", "Below")
  ) %>%
  group_by(strat) %>%
  summarize(sd_enroll = sd(enroll))
```

Since the variability of the school enrollment sizes in the above median size
schools is roughly five times that in the below median size schools, we'd sample
from the two strata at a 5:1 ratio, respectively. Or, explicitly, we'd sample
160 schools from the above median school size and 40 schools from the below
median school size.

```{r}
api_opt_strat <- as_tibble(apipop) %>%
  filter(!is.na(enroll)) %>%
  transmute(
    enroll = enroll,
    strat = if_else(enroll > median(enroll, na.rm = TRUE), "Above", "Below")
  )

above <- api_opt_strat %>%
  filter(strat == "Above") %>%
  mutate(fpc = n()) %>%
  slice_sample(n = 160)

below <- api_opt_strat %>%
  filter(strat == "Below") %>%
  mutate(fpc = n()) %>%
  slice_sample(n = 40)

opt_strat_design <- svydesign(
  ids = ~1, strata = ~strat, fpc = ~fpc,
  data = rbind(above, below),
)

svytotal(~enroll, opt_strat_design)
```

The mean estimate is slightly closer to the true value,
`r sum(api_opt_strat$enroll)` but the standard error is slightly larger (119K vs
114K) compared to the previous stratified design. However, the other design
sampled 1000s of schools per strata so this is remarkably efficient.

I won't perform the other comparisons, but one would expect this design to be
much less efficient at estimating the other variables if they are not well
correlated with enrollment size.

7.  Figure 2.1 shows that the mean school size (enroll) in simple random samples
    of size 200 from the Academic Performance Index population has close to a
    Normal distribution.

<!-- -->

a)  Construct similar graphs for SRS of size 200, 50, 25, 10.

I've already done something like this at the start of the chapter. We'd expect
the central limit theorem (the normality of the sample means) to be better for
the larger sample sizes listed. Or rather, we might not trust the standard error
for the sample size of 10 to really represent the variability of the sample
mean.

b)  Repeat for median school size.

```{r sample_median_CLT}
pop_median <- median(apipop$enroll)
p1 <- apipop %>%
  ggplot(aes(x = enroll)) +
  geom_histogram() +
  xlab("Student Enrollment") +
  geom_vline(xintercept = pop_median, linetype = 2, color = "red") +
  ggtitle("Distribution of School Enrollment",
    subtitle = "Median Enrollment Identified"
  )

p <- replicate(n = 500, {
  apipop %>%
    sample_n(200) %>%
    pull(enroll) %>%
    median(., na.rm = TRUE)
})

p <- tibble(sample_ix = 1:500, sample_median = p) %>%
  ggplot(aes(x = sample_median)) +
  geom_histogram() +
  xlab("Student Enrollment Medians") +
  geom_vline(
    xintercept = pop_median,
    linetype = 2, color = "red"
  ) +
  ggtitle("Distribution of Sample Medians")
p1 + p
```

c)  Repeat for mean school size in stratified samples of size 100, 52, 24, 12
    using the same stratification proportions (50% elementary, 25% middle
    schools, 25% high schools) as in the built-in stratified sample.

The same result holds since the samples are independent within and across strata
as well.

```{r}
ns <- c(100, 52, 24, 12)
simdf <- map_dfr(1:200, function(sim_ix) {
  map_dfr(ns, function(n) {
    apipop %>%
      filter(stype == "E") %>%
      mutate(fpc = n()) %>%
      slice_sample(n = n * .5) %>%
      rbind(
        .,
        apipop %>%
          filter(stype != "E") %>%
          group_by(stype) %>%
          mutate(fpc = n()) %>%
          slice_sample(n = n * .25)
      ) %>%
      as_survey_design(strata = stype, fpc = fpc) %>%
      summarize(mean_enroll = survey_mean(enroll, na.rm = TRUE)) %>%
      mutate(sim_ix = sim_ix, n = n)
  })
})
simdf %>%
  ggplot(aes(x = mean_enroll, fill = factor(n))) +
  geom_histogram() +
  theme(legend.title = element_blank()) +
  ggtitle("CLT for stratified samples of different sizes.")
```

8.  In a design with just two strata write the sample sizes as $n_1$ and $n-n_1$
    so that there is only one quantity that can be varied. Differentiate the
    variance of the total with respect to $n_1$ to find the optimal allocation
    for two strata. Extend this to any number of strata by using the fact that
    an optimal allocation cannot be improved by moving samples from one stratum
    to another stratum.
    
$$
\hat{V}[\hat{T}] = V_1 + V_2 \\
V_1 = \frac{N_1 - n_1}{N_1} N_1^2 \frac{\sigma^2_1}{n_1} \\ 
V_2 = \frac{N_2 - (n - n_1)}{N_2} N_2^2 \frac{\sigma^2_2}{n_2}
$$
taking the derivative ...

$$
\frac{d\hat{V}[\hat{T}]}{dn_1} = \frac{dV_1}{dn_1} + \frac{dV_2}{dn_1} \\
= \frac{-N_1^2 \sigma^2_1}{n_1^2} + \frac{N_2^2 \sigma_2^2}{(n - n_1)^2}
$$
setting to zero and and solving for $n_1$ we get
$$
\frac{-N_1^2 \sigma^2_1}{n_1^2} + \frac{N_2^2 \sigma_2^2}{(n - n_1)^2} = 0 \\
\iff \\
\frac{N_2^2\sigma^2_2}{(n-n_1)^2} = \frac{N_1^2\sigma_1^2}{n_1^2}\\
\iff \\
\frac{n_1^2}{(n-n_1)^2} = \frac{N_1^2\sigma_1^2}{N_2^2\sigma^2_2} \\
\iff \\
\frac{n_1}{(n-n_1)} = \frac{N_1\sigma_1}{N_2\sigma}  \\
\iff \\ 
n_1 = \frac{nN_1\sigma_1}{N_2\sigma_2(1 + \frac{N_1\sigma_1}{N_2\sigma_2})} \\
 = \frac{nN_1\sigma_1}{N_2\sigma_2 + N_1\sigma_1}
$$

Where the square root is taken over variables constrained to be positive so
we only have the positive values as the solution to the equation.

Also, $N_1, N_2$ are taken to be the population strata sizes and 
$\sigma_1, \sigma_2$ are the strata standard deviations.

We can check the second derivative to ensure this is a global optima or we can
use the fact that the variance is a quadratic function and is therefore convex.
Consequently, there is only 
[one global optima](https://en.wikipedia.org/wiki/Convex_function#Properties).

Examining the expression - we see the optimal strata size is the
variance of each strata weighted by the size of the strata as a fraction of 
the same value added across all strata, i.e. the population variance.

Here we've derived the solution for the "first" strata, but this is arbitrary
and there would be a similar value for any strata, for a design with any number
of strata.

9.  Write an R function that takes inputs
    $n_1, n_2, N_1, N_2, \sigma^2_1, \sigma^2_2$ and computes the variance of
    the population total in a stratified sample. Choose some reasonable values
    of the population sizes and variances, and graph this function as $n_1$ and
    $n_2$ change, to find the optimum and to examine how sensitive the variance
    is the precise values of $n_1$ and $n_2$.

```{r}
strat_var_sample <- function(n_1, n_2, N_1, N_2, sigma_1, sigma_2) {
  one_strat_var <- function(n, N, sigma) {
    (N - n) / N * N^2 * sigma^2 / n
  }
  return(one_strat_var(n_1, N_1, sigma_1) + one_strat_var(n_2, N_2, sigma_2))
}
expand.grid(
  n_1 = seq(2, 100, 10), n_2 = seq(2, 100, 10),
  N_1 = 1E3, N_2 = 1E3, sigma_1 = 1, sigma_2 = 1
) %>%
  as_tibble() %>%
  mutate(
    var = map2_dbl(n_1, n_2, strat_var_sample, unique(N_1), unique(N_2), unique(sigma_1), unique(sigma_2)),
    n_2 = factor(n_2)
  ) %>%
  ggplot(aes(x = n_1, y = var, color = n_2)) +
  geom_point() +
  geom_line() +
  ylab("Variance") +
  ggtitle("Two Strata Design Variance", subtitle = "For Varying Strata Sizes")
```

I think the point Lumley is after is that the variance doesn't change 
dramatically after each sample size is roughly more than ten. This is the
quadratic behavior of the variance at play. Obviously the "optimal" variance
will be found at the highest $n_1$ and $n_2$ as those values will provide the 
lowest variance. In terms of where the greatest efficiency lies, however, 
we see the greatest change in the variance estimates after the two sample 
sizes are greater than 10, as stated previously.


10. Verify that equation 2.2 gives the HTE of variance for a SRS


a)  Show that when $i \neq j$ $$
    \pi_{ij} = \frac{n}{N}n - 1N - 1
    $$
This follows from combinatorics. We want the number of combinations in which
two (different) items are chosen from a sample of n together, divided by the 
total number of combinations of n samples from a population of size N. Though,
it isn't clear to me whether the overall sampling design should be with or 
without replacement - I assume without below.

$$
\frac{n \choose 2}{N\choose n} = \frac{n!}{(n-2)!2!} \frac{(N-n)!n!}{N!} \\
=\frac{n(n-1)n!}{2N(N-1)}
$$
I don't see yet how this reduces to the intended form but may return to this
later.

b)  Compute $\pi_{ij} - \pi_i \pi_j$

c)  Show that the equation in exercise 1.10 (c) reduces to equation 2.2

d)  Suppose instead each individual in the population is independently sampled
    with probability $\frac{n}{N}$, so that the sample size $n$ is *not* fixed.
    Show that the finite population correction disappears from equation 2.2 for
    this *Bernoulli sampling* design.

# Chapter 3: Cluster Sampling

## Why Clusters? The NHANES design

Why sample clusters? Because sometimes it's easier than sampling individuals.
Specifically, in cases where the *cost* of sampling individuals can be quite
high, sampling clusters can be more efficient. This is in spite of the fact that
within cluster correlation tends to be positive, reducing the information in the
sample. Lumley uses the NHANES survey to motivate this idea: moving mobile
examination centers all across the country to sample individuals is extremely
expensive. By sampling a large number of individuals within a census tract
aggregation area the NHANES survey is able to reduce the cost of their effort at
a reasonable expense in precision.

### Single-stage and multistage designs

Depending on the type of clusters involved it can be easy to sample the entire
cluster as classrooms, medical practice and workplaces are, however it is more
likely that some subsampling within clusters will be performed for the sake of
efficiency. As Lumley notes, clusters in the first stage are called *Primary
Sampling Units* or PSUs. "Stages" refer to the different levels at which
sampling occurs. E.g. Sampling individuals within sampled census tracts within a
state would involve sampling census tracts in the first stage and then
individuals in the second stage. The diagram below communicates this idea
graphically.

```{r, echo = FALSE}
grViz("
digraph dot {
graph [layout = dot]
node [shape = circle,
style = filled,
color = grey]

node [fillcolor = red, label = 'US State (strata)']
a

node [fillcolor = green, label = 'census tract (PSU)']
b

node [fillcolor = gold, label = 'households (SSU)']

edge [color = grey]
a -> {b}
b -> {c}
}")
```

Sampling weights are determined assuming independence across stages --- e.g. if
a cluster of houses is sampled with probability $\pi_1$ and a household is
sampled within that cluster with probability $\pi_2$ then the sampling
probability for that house is $\pi = \pi_1 \times \pi_2$ and it's weight is the
inverse of that probability. Note that this requires that clusters be mutually
exclusive - a sampled unit can belong only to one cluster and no others.
Further, note that we can still have biased sampling *within* a stage, as
independence is only required across stages to use to find probabilities via
their product.

Lumley goes on to describe how cluster sampling and individual sampling can be
mixed since each stratum of a survey can be thought of as a separate and
independent sample it is trivial to combine single stage sampling in one stratum
and multistage sampling in another; a stratified random sample can be used in
high density regions where measurement of multiple units is less costly and a
cluster sample can be taken in low density regions where the cost of each
additional unit is more costly.

The statistical rationale behind this strategy is fairly straightforward ---
since the variance of the sum is the sum of the variances of each stage
(assuming independence) each sampled cluster in a multistage sample can be
considered as a population for further sampling. Lumley uses the example of a
simplified NHANES design, where 64 regions are grouped into 32 strata. A simple
random sample of 440 individuals are then measured in each region. In Lumley's
words,

> The variance of an estimated total from this design can be partitioned across
> two sources: the variance of each estimated regional total around the true
> total of the region and the variance that would result if the true total for
> each of the 64 sampled regions were known exactly.

In my own words and understanding, I understand there to be variance that comes
from grouping the 64 regions into 32 strata --- so there is uncertainty across
region and then the uncertainty within that region that results from the sample
of *only* a subset of the population.

## Describing Multi Stage Designs to R

In order to specify a single stage cluster sample or a multistage sample treated
as a single stage sample with replacement, the main difference is that the PSU
identifier needs to be supplied to the `id` argument, as follows.

```{r nhanes3_data, eval = FALSE}
# Data originally found at
# "https://github.com/cran/LogisticDx/blob/master/data/nhanes3.rda"
```

```{r}
names3 <- load("Data/nhanes/nhanes3.rda")
as_tibble(nhanes3)
```

```{r}
svydesign(
  id = ~SDPPSU6, strat = ~SDPSTRA6,
  weight = ~WTPFHX6,
  ## nest = TRUE indicates the PSU identifier is nested
  ## within stratum - repeated across strata
  nest = TRUE,
  data = nhanes3
)
```

SDPPSU6 is the pseudo PSU variable, and SDPSTRA6 is the stratum identifier
defined for the single stage analysis.

For example, a two stage design for the API population that samples 40 school
districts, then five schools within each district , the design has population
size 757 at the first stage for the number of school districts in CA and the
number of schools within each district for the second stage. The weights need
not be supplied if they can be worked out from the other arguments.

```{r}
data(api)
as_tibble(apiclus2)
```

```{r}
## dnum = district id
## snum = school id
## fpc1 = school id number
clus1_design <- svydesign(id = ~dnum, fpc = ~fpc, data = apiclus1)
clus2_design <- svydesign(
  id = ~ dnum + snum, fpc = ~ fpc1 + fpc2,
  data = apiclus2
)
clus2_design
```

## Strata with only one PSU

When only one PSU exists within a population stratum, the sampling fraction
*must* be 100%, since otherwise it would be 0%. In this case, the stratum does
not contribute to the first stage variance and it should be ignored in
calculating the first stage variance. Lumley argues that the best way to handle
a stratum with only one PSU is to combine it with another stratum, one that is
chosen to be similar based on *population* data available before the study was
done. The `survey` package has two different methods implemented to handle
"lonely" PSU's. Lumley has written further on this topic
[here](http://r-survey.r-forge.r-project.org/survey/exmample-lonely.html).

## How good is the single-stage approximation?

Here Lumley walks through an example detailing the trade-offs involved in using
the single stage approximation. I'll try to come up with a simulated example
later as the data is not listed on the book's
[website](https://r-survey.r-forge.r-project.org/svybook/) nor is it clear how
to reassemble his dataset from the files at the [NHIS
site](https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/NHIS/1992/).

## Sampling by Size

> Why do white sheep eat more than black sheep? There are more white sheep than
> black sheep

A specific design theory, *Probability-proportional-to-size* (PPS), cluster
sampling is a sampling strategy that exploits the fact that for a simple random
sample of an unstratified population $\pi_i$ can be chosen such that it is
approximately proportional to $X_i$, the variable of interest, the resulting
variance of the estimate of the total
$V[\hat{T}] = \frac{N-n}{N} N^{2} \frac{V[X]}{n}$ can then be controlled to be
quite small. These are the same ideas I discussed at the start of the notes but
more discussion on this topic can be found in [@tille2006sampling;
@hanif1980sampling].

```{r}
data(election)
election <- as_tibble(election) %>%
  mutate(
    votes = Bush + Kerry + Nader,
    p = 40 * votes / sum(votes)
  )
election %>%
  ggplot(aes(x = Kerry, y = Bush)) +
  geom_point() +
  scale_y_log10() +
  scale_x_log10() +
  ggtitle("Correlation in Voting Totals from US 2004 Presidential Election",
    subtitle = "Both x and y axes are on log 10 scales."
  )
```

When Lumley's book was written, only the single stage approximation of PPS could
be analyzed using the `survey` package. A demo is shown below using the voting
data, where a PPS sample is constructed and then analyzed.

```{r}
data(election)
election <- as_tibble(election) %>%
  mutate(
    votes = Bush + Kerry + Nader,
    p = 40 * votes / sum(votes)
  )
election
insample <- sampling::UPtille(election$p)
ppsample <- election[insample == 1, ]
ppsample$wt <- 1 / ppsample$p
pps_design <- svydesign(id = ~1, weight = ~wt, data = ppsample)
pps_design
```

```{r}
svytotal(~ Bush + Kerry + Nader, pps_design, deff = TRUE)
```

## Loss of information from sampling clusters

The loss of precision per observation from cluster sampling is given by the
design effect.

> "For a single-stage cluster sample with all clusters having the same number of
> individuals, $m$, the design effect is

$$
DEff = 1 + (m-1)\rho,
$$

> where $\rho$ is the within-cluster correlation.

Lumley illustrates how design effects can illustrate the impact on inference
using the California school data set from before as well as the Behavioral Risk
Factor Surveillance System from 2007.

```{r}
svymean(~ api00 + meals + ell + enroll, clus1_design, deff = TRUE)
```

In the above, the variance is up to 10 times higher in the cluster sample as
compared to a simple random sample.

```{r}
## Lumley renames clus2_design to dclus2 from before. I maintain the same names.
svymean(~ api00 + meals + ell + enroll, clus2_design, deff = TRUE, na.rm = TRUE)
```

These values increase slightly for all measures except `api00` in the two stage
cluster sampling design. Lumley points out that these large design effects
demonstrate how variable the measures of interest are between cluster,
suggesting that the sampling of clusters, while efficient economically are not
as efficient statistically.

Similarly, when computing the proportion of individuals who have more than 5
servings of fruits and vegetables a day (X_FV5SRV = 2), as well as how often
individuals received a cholesterol test in the past 5 years (X_CHOLCHK = 1) from
the 2007 Behavioral Risk Factor Surveillance System dataset, we see design
effects that reflect the geographic variability across the blocks of telephone
numbers that were sampled for the survey.

```{r BRFSS_read_in}
brfss <- svydesign(
  id = ~X_PSU, strata = ~X_STATE, weight = ~X_FINALWT,
  data = "brfss", dbtype = "SQLite",
  dbname = "data/BRFSS/brfss07.db", nest = TRUE
)
brfss
```

```{r, brfss_geo_effects}
food_labels <- c("Yes Veg", "No Veg")
chol_labels <- c("within 5 years", ">5 years", "never")
svymean(
  ~ factor(X_FV5SRV) +
    factor(X_CHOLCHK),
  brfss,
  deff = TRUE
)
```

## Repeated Measurements

Lumley notes that design based inference continues to differ from model based in
its analysis of repeated measurements. Where model based inference is careful to
account for modeling the -- for example -- within person or within household
correlation in a cohort study, no such adjustment is required in a designed
survey other than adjusting and using the appropriate weights - treating the
repeated measurement like another stage of clustering in the sampling.

Lumley illustrates this with the Survey of Income and Program Participation
(SIPP) panel survey.

> Each panel is followed for multiple years, with subsets of the panel
> participating in four month waves of follow-up... wave 1 of the 1996 panel,
> which followed 36,730 households with interviews every four months, starting
> in late 1995 or early 1996... The households were recruited in a two-stage
> sample. The first stage sampled 322 counties or groups of counties as PSUs;
> the second stage sampled households within these PSUs.

Lumley demonstrates how to estimate repeated measures with panel data using the
`survey` package via the code below. 5 quantiles are estimated across the
population and across the 8 months. When Lumley mentions that there is no need
for adjusting for correlation in the blockquote above, I believe he is referring
to the within-month point estimates. If we were to try and estimate the change
in, say, income as a function of other covariates I believe we would want to
adjust for correlation in order to get the appropriate standard errors. For the
point estimates Lumley points out that the weights are exactly as required for
the per-month estimate, but would need to be divided by the number of samples
when totaling across the number of measurements. Proportions or regressions are
invariant to this scaling factor so no adjustment is needed there.

```{r}
sipp_hh <- svydesign(
  id = ~ghlfsam, strata = ~gvarstr, nest = TRUE,
  weight = ~whfnwgt, data = "household", dbtype = "SQLite",
  dbname = "Data/SIPP/sipp.db"
)
sipp_hh <- update(sipp_hh,
  month = factor(rhcalmn,
    levels = c(12, 1, 2, 3, 4, 5, 6),
    labels = c(
      "Dec", "Jan", "Feb", "Mar",
      "Apr", "May", "Jun"
    )
  )
)
qinc <- svyby(~thtotinc, ~month, svyquantile,
  design = sipp_hh,
  quantiles = c(0.25, 0.5, 0.75, 0.9, 0.95), se = TRUE
)
pltdf <- as_tibble(qinc) %>%
  select(month, contains("thtotinc"), -contains("se")) %>%
  gather(everything(), -month, key = "quantile", value = "Total Income") %>%
  mutate(quantile = as.numeric(str_extract(quantile, "[0-9].[0-9]?[0-9]")) * 100)

se <- as_tibble(qinc) %>%
  select(month, contains("se")) %>%
  gather(everything(), -month, key = "quantile", value = "SE") %>%
  mutate(quantile = as.numeric(str_extract(quantile, "[0-9].[0-9]?[0-9]")) * 100)

pltdf <- pltdf %>%
  left_join(se) %>%
  mutate(
    lower = `Total Income` - 2 * SE,
    upper = `Total Income` + 2 * SE
  )
```

```{r}
pltdf %>%
  mutate(quantile = factor(quantile)) %>%
  ggplot(aes(x = month, y = `Total Income`, color = quantile)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  xlab("Month in 1995/1996") +
  ylab("Total Income (USD)") +
  ggtitle("Total Income Quantiles",
    subtitle = "Survey of Income and Program Participation"
  )
```

Lumley notes here that we're only talking about correlation at all here because
the same individuals are being measured across time. In a study like NHANES
that recruits different individuals each year, we can effectively assume the
samples are independent since the overall population si so big.

Estimation would be much more complicated if the samples overlapped in some way.


## Questions

1.  The web site has data files demo_x.xpt of demographic data and bpx_c.xpt of
    blood pressure data from NHANES 2003-2004. Code to load and merge these data
    sets is in Appendix B, in Figure B.1

<!-- -->

a.  Construct a survey design object with these data.

```{r 31_a}
## data are from the book website:
# https://r-survey.r-forge.r-project.org/svybook/
# demographic data
ddf <- haven::read_xpt("data/nhanesxpt/demo_c.xpt")
# blood pressure data
bpdf <- haven::read_xpt("data/nhanesxpt/bpx_c.xpt")

bpdf <- merge(ddf, bpdf, by = "SEQN", all = FALSE) %>%
  mutate(
    sys_over_140 = (BPXSAR > 140) * 1,
    dia_over_90 = (BPXDAR > 90) * 1,
    hbp = (sys_over_140 + dia_over_90 == 2) * 1,
    age_group = cut(RIDAGEYR, c(0, 21, 65, Inf)),
    sex = factor(RIAGENDR, levels = 1:2, labels = c("Male", "Female"))
  )

bpdf_design <- bpdf %>%
  select(
    sys_over_140, dia_over_90, hbp, WTMEC2YR, SDMVPSU, SDMVSTRA,
    age_group, sex, RIDAGEYR, BPXSAR, BPXDAR, RIAGENDR, RIDAGEMN,
  ) %>%
  as_survey_design(
    weights = WTMEC2YR,
    id = SDMVPSU,
    strata = SDMVSTRA,
    nest = TRUE
  )
bpdf_design
```

b.  Estimate the proportion of the US population with systolic blood pressure
    over 140 mm HG, with diastolic blood pressure over 90 mm Hg, and with both.
    
Lumley doesn't tell us which variable name corresponds to the measurements 
indicated and I didn't see any documentation in the files included so I just
guess here.
```{r 31_b}
bpdf_design %>%
  summarize(
    prop_hbp_one =
      survey_ratio(sys_over_140, n(), na.rm = TRUE, vartype = "ci", deff = TRUE),
    prop_hbp_two =
      survey_ratio(sys_over_140, n(), na.rm = TRUE, vartype = "ci", deff = TRUE),
    prob_hbp = survey_ratio(hbp, n(), na.rm = TRUE, vartype = "ci", deff = TRUE)
  ) %>%
  gather(everything(), key = "metric", value = "value")
```

c. Estimate the design effects for these proportions.

Included in the output above.

d. How do these proportions vary by age (`RIDAGEYR`) and gender (`RIAGENDR`)

```{r 31_d}
nhanes_ests <- bpdf_design %>%
  group_by(sex, age_group) %>%
  summarize(
    prop_hbp_one =
      survey_ratio(sys_over_140, n(), na.rm = TRUE, vartype = "ci", deff = TRUE),
    prop_hbp_two =
      survey_ratio(sys_over_140, n(), na.rm = TRUE, vartype = "ci", deff = TRUE),
    prob_hbp = survey_ratio(hbp, n(), na.rm = TRUE, vartype = "ci", deff = TRUE)
  ) %>%
  ungroup()
nhanes_ests
```

This produces a bunch of output, so I plot the high blood pressure result ---
both high systolic and diastolic blood pressure -- below.

```{r 31_compiled}
nhanes_ests %>%
  select(age_group, sex, prob_hbp, prob_hbp_low, prob_hbp_upp) %>%
  filter(!is.na(age_group)) %>%
  ggplot(aes(x = age_group, y = prob_hbp, color = sex)) +
  geom_pointrange(aes(ymin = prob_hbp_low, ymax = prob_hbp_upp),
    position = position_dodge(width = .25)
  ) +
  ylab("% US Population with High Blood Pressure") +
  xlab("Age Group") +
  ggtitle("Prevalence of High Blood Pressure in U.S. Across Age and Sex",
    subtitle = "Data from NHANES 2003-2004"
  ) +
  scale_y_continuous(labels = scales::percent)
```

3.2 Repeat the sampling and estimation in Figure 3.4 1000 times.

FYI the `sampling::UPtille` function takes a while so running this simulation
1000 times takes a while.
```{r 32_simulated_pps}
OneSimulation <- function() {
  insample <- sampling::UPtille(election$p)
  ppsample <- election[insample == 1, ]
  ppsample$wt <- 1 / ppsample$p
  pps_design <- svydesign(id = ~1, weight = ~wt, data = ppsample, pps = "brewer")
  total <- svytotal(~ Bush + Kerry + Nader, pps_design)
  std_err <- sqrt(diag(attr(total, "var")))
  ci <- confint(total)
  out <- cbind(total, std_err, ci)
}
total_sims <- replicate(10, OneSimulation())
```

a) Check that the mean of the estimated totals is close to the true population 
totals.

```{r pps_totals}
estimated_totals <- as_tibble(t(rowMeans(total_sims[, 1, ]))) %>%
  mutate(label = "Estimate")

true_totals <- as_tibble(t(colSums(election[, c("Bush", "Kerry", "Nader")]))) %>%
  mutate(label = "Truth")

rbind(estimated_totals, true_totals) %>%
  gather(everything(), -label, key = "Candidate", value = "Vote Count") %>%
  spread(label, `Vote Count`) %>%
  gt::gt() %>%
  gt::fmt_scientific() %>%
  gt::tab_header("Simulated Total Comparison")
```

These are quite close.

b). Compute the mean of the estimated standard errors and compare it to the
true simulation standard error, that is, the standard deviation of the 
estimated totals.

```{r pps_stderrs, eval = FALSE}
estimated_stderrs <- as_tibble(t(rowMeans(total_sims[, 2, ]))) %>%
  mutate(label = "Estimate")

true_stderr <- as_tibble(apply(total_sims, 1, sd)) %>%
  mutate(label = "Truth", Candidate = c("Bush", "Kerry", "Nader")) %>%
  spread(Candidate, value)

rbind(estimated_stderrs, true_stderr) %>%
  gather(everything(), -label, key = "Candidate", value = "Vote Std.Err") %>%
  spread(label, `Vote Std.Err`) %>%
  gt::gt() %>%
  gt::fmt_scientific() %>%
  gt::tab_header("Simulated Standard Error Comparison")
```

Same as above.

c) Estimate 95% confidence intervals for the population totals and compute the 
proportion of intervals that contain the true population value.

```{r pps_cis, eval = FALSE}
totals <- unlist(true_totals[, 1:3])
prop_contained <- rowMeans((total_sims[, 3, ] < totals &
  total_sims[, 4, ] > totals) * 1)
prop_contained
```

We see that the proportion contained by the interval is near the 95% nominal 
value.


3.3  The National Longitudinal Study of Youth is documented at 
www.nlsinfo.org/nlsy97/nlsdocs/nlsy97/maintoc.html

a) What are the stages of sampling and the sampling units at each stage?


From the 
[website](https://www.nlsinfo.org/content/cohorts/nlsy97/intro-to-the-sample/sample-design-screening-process)
the sampling occurred in 2 phases (see image below).

![](https://www.nlsinfo.org/sites/default/files/attachments/sample-figure%201.JPG)

The first phase screened households and the second identified eligible
respondents. I think this would technically be called a two phase sample 
(discussed in chapter 8) but given the population sizes involved it may be that
there was no need to account for the potential dependence here. 

The sampling unit in the first stage came from NORC's 1990 sampling design which
used Standard Metropolitan Statistical Areas or non-metropolitan counties. That
is, according to the general social survey 
[documentation](https://gss.norc.org/Documents/codebook/GSS_Codebook_AppendixA.pdf)

Subsequent sampling units are segments, households, and then members of 
households.

b) What would the strata and PSUs be for the single stage approximation to 
the design?

I don't know. It isn't clear how to reconstruct Lumley's example given that
the data is not available. Looking at the NHIS 
[website](https://www.cdc.gov/nchs/nhis/sudaan.htm) it looks like the 
strata and PSU information for a single stage approximation are given. 
When looking for the same information for the NLYS data I don't 
[see](https://www.nlsinfo.org/content/cohorts/nlsy97/other-documentation/errata/errata-nlsy97-round-15-release/calculating-design) equivalent instructions on how to construct a single stage 
approximation. His description in the book here isn't very forthcoming either 
but I'd guess that one could just concatenate the PSU and SSU labels and the 
same for the strata and then use those in a one stage design. This doesn't look 
exactly like what Lumley does in his example.

3.4  The British Household Panel Survey (BHPS) is documented at 
http://www.iser.essex.ac.uk/survey/bhps (this website is no longer accurate) .

a) What are the stages of sampling, strata and the sampling units at each stage?

The website given is no longer accurate. Clicking through the documentation of 
the "Understanding Society" 
[website](https://www.understandingsociety.ac.uk/documentation/mainstage/user-guides/main-survey-user-guide/study-design/) 
it looks like the BHPS has been combined with other surveys. 
When I look at more documentation,
([1](https://www.understandingsociety.ac.uk/wp-content/uploads/documentation/user-guides/6614_main_survey_sample_design.pdf),
[2](https://repository.essex.ac.uk/21094/1/bhps-harmonised-user-guide.pdf#page=6.75),
[3](https://www.iser.essex.ac.uk/wp-content/uploads/bhps/documentation/volumes/5151userguide_vola.pdf)),
the last of these being the most pertinent, I see a variety of designs by wave.
It looks like the design was a two stage stratified sample where the sampling
frame was the Postcode Address File for Great Britian, excluding Northern
Ireland. 250 postcodes were chosen as the primary sampling unit, in the 
second stage, "delivery points" which are roughly equivalent to addresses were
then selected.

b) What would the strata and PSUs be for the single stage approximation to
the design?

Again, my best guess is to concatenate the postcodes and delivery addresses
to construct the single stage identifiers, and the same for the strata.


3.5 Statistics New Zealand lists survey topics at 
http://www.stats.govt.nz/datasets/a-z-list.htm . Find the Household Labour Force
Survey.

a) What are the stages of sampling and the sampling units at each stage?

Again, that site is no longer valid. The current help 
[page](https://www.stats.govt.nz/help-with-surveys/list-of-stats-nz-surveys/about-the-household-labour-force-survey/)
for the household labor survey simply says,

> Approximately fifteen thousand (15,000) households take part in this survey
every three months. A house is selected using a fair statistical method to
ensure the sample is an accurate representation of New Zealand. Every person 
aged 15 years or over living in a selected house needs to take part.

A different [doc](https://www.stats.govt.nz/assets/Uploads/Retirement-of-archive-website-project-files/Methods/Household-Labour-Force-Survey-sources-and-methods-2016/hlfs-sources-and-methods-2016.pdf#page=11.08)
I found on google searching listed the 2016 survey design as a 2 stage 
design where samples are drawn from strata in the first stage. The PSU's 
are "meshblocks" which appear to be the NZ equivalent of a U.S. 
census block / tract.


b) What would the strata and PSUs be for the single stage approximation to
the design?

Same answer here as previously.

3.6 This exercise uses the Washington State Crime data for 2004 as the 
population. The data consists of crime rates and population size for the
police districts (in cities/towns) and sheriffs' offices 
(in unincorporated areas), grouped by county.

I took the data from this 
[website](https://www.waspc.org/cjis-statistics---reports). Specifically,
[this excel sheet](https://waspc.memberclicks.net/index.php?option=com_content&view=article&id=121:crime-in-wa-archive-folder&catid=20:site-content). One of the tricky things about using this data was the fact 
that several police districts are reported as having zero associated population.
I removed these from the dataset to make things simpler.


a) Take a simple random sample of 10 counties from the state and use all the
data from the sampled counties. Estimate the total number of murders and
burglaries in the state.

```{r wacrime_36a}
# data from
wa_crime_df <- readxl::read_xlsx("data/WA_crime/1984-2011.xlsx", skip = 4) %>%
  filter(Year == "2004", Population > 0) %>%
  mutate(
    murder = `Murder Total`,
    murder_and_crime = `Murder Total` + `Burglary Total`,
    violent_crime = `Violent Crime Total`,
    burglaries = `Burglary Total`,
    property_crime = `Property Crime Total`,
    state_pop = sum(Population),
    County = stringr::str_to_lower(County),
    num_counties = n_distinct(County),
  ) %>%
  group_by(County) %>%
  mutate(num_agencies = n_distinct(Agency)) %>%
  ungroup() %>%
  select(
    County, Agency, Population, murder_and_crime, murder, violent_crime,
    property_crime, burglaries, num_counties, num_agencies
  )

true_count <- sum(wa_crime_df$murder_and_crime)
county_list <- unique(wa_crime_df$County)
county_sample <- sample(county_list, 10)
part_a <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  ) %>%
  summarize(total = survey_total(murder_and_crime)) %>%
  mutate(Q = "a")
part_a
```


b) Stratify the sampling so that King County is sampled with 100% probability
together with a simple random sample of five other counties. Estimate the
total number of of murders and burglaries in the state and compare to the
previous estimates.

```{r wacrime_36b}
county_sample <- sample(county_list[-which(county_list == "king")], 5)
county_sample <- c(county_sample, "king")
part_b <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  mutate(
    strata_label = if_else(County == "king", "strata 1", "strata 2"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1)
  ) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  ) %>%
  summarize(
    total = survey_total(murder_and_crime)
  ) %>%
  mutate(Q = "b")
part_b
```

c) Take simple random samples of five police districts from King County and
five counties from the rest of the state. Estimate the total number of murders
and burglaries in the state and compare to the previous estimates.

This is a stratified two-stage sample design with no uncertainty in the 
first stage in one (king county) strata, and no uncertainty in the second stage 
in the other (non-king counties) strata.
```{r wacrime_36c}
king_districts <- wa_crime_df %>%
  filter(County == "king") %>%
  pull(Agency)
sampled_king_districts <- sample(king_districts, 5)
sampled_counties <- sample(county_list, 5)

part_c <- wa_crime_df %>%
  filter(County %in% sampled_counties | Agency %in% sampled_king_districts) %>%
  mutate(
    strata_label = if_else(County == "king", "King County", "WA Counties"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1),
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  ) %>%
  summarize(total = survey_total(murder_and_crime, vartype = "se")) %>%
  mutate(Q = "c")
part_c
```


d) Take a probability proportional to size (PPS) sample of 10 police districts.
Estimate the total number of murders and burglaries in the state and compare
to the previous estimates.

```{r wacrime_36d}
pi <- sampling::inclusionprobabilities(a = wa_crime_df$Population, n = 10)
part_d <- wa_crime_df %>%
  mutate(
    pi = pi,
    in_sample = sampling::UPbrewer(pi)
  ) %>%
  filter(in_sample == 1) %>%
  as_survey_design(probs = pi) %>%
  summarize(total = survey_total(murder_and_crime)) %>%
  mutate(Q = "d")
part_d
```

This has the lowest standard error yet, likely since the sampling was
specifically designed to capture high density districts.

e) Take a simple random sample of counties and include all the police districts.
Estimate the total number of murders and burglaries in the state and
compare to the previous estimates.

```{r wacrime36e}
county_sample <- sample(county_list, 10)
part_e <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  ) %>%
  summarize(total = survey_total(murder_and_crime)) %>%
  mutate(Q = "e")
part_e
```


I'll compare the standard error of all the estimates now.

```{r compare_36_answers}
rbind(part_a, part_b, part_c, part_d, part_e) %>%
  select(Q, total_se) %>%
  gt::gt()
```

We see the highest variance in estimates from the simple random samples - 
Q's a) and e). We see the lowest variance from part d) which used the 
proportional to size sampling scheme. Finally, we see the two 
stratified multi-stage samples have variances in between, all of which makes 
sense.

3.7 Use the household data from the 1966 SIP panel to estimate the 25th, 50th,
75th, 90th and 95th percentiles of income for households of different sizes
(`ehhnumpp`) averaged over the fourth months. You will want to recode the large
values of `ehhnumpp` to a a single category. Describe the patterns you see.

For this question we effectively copy the code from the "Repeated Measures"
section, looking at quantile by a recoded household size now, instead of
month.

```{r 37}
sipp_hh <- update(sipp_hh,
  household_size = factor(
    case_when(
      ehhnumpp <= 8 ~ as.character(ehhnumpp),
      TRUE ~ ">=9"
    ),
    levels = c(as.character(1:8), ">=9")
  )
)
qinc <- svyby(~thtotinc, ~household_size, svyquantile,
  design = sipp_hh,
  quantiles = c(0.25, 0.5, 0.75, 0.9, 0.95), se = TRUE
)
```

```{r}
pltdf <- as_tibble(qinc) %>%
  select(household_size, contains("thtotinc"), -contains("se.")) %>%
  gather(everything(), -household_size, key = "quantile", value = "Total Income") %>%
  mutate(quantile = as.numeric(str_extract(quantile, "[0-9].[0-9]?[0-9]")) * 100)

se <- as_tibble(qinc) %>%
  select(household_size, contains("se.")) %>%
  gather(everything(), -household_size, key = "quantile", value = "SE") %>%
  mutate(quantile = as.numeric(str_extract(quantile, "[0-9].[0-9]?[0-9]")) * 100)

pltdf <- pltdf %>%
  left_join(se) %>%
  mutate(
    lower = `Total Income` - 2 * SE,
    upper = `Total Income` + 2 * SE
  )

pltdf %>%
  mutate(quantile = factor(quantile)) %>%
  ggplot(aes(x = household_size, y = `Total Income`, color = quantile)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  xlab("Household Size") +
  ylab("Total Income (USD)") +
  ggtitle("Total Income Quantiles",
    subtitle = "Survey of Income and Program Participation"
  )
```

In the plot above we can see that the income variability gets wider as 
household size increases but then plateaus at around ~ 5. Additionally, there
are few samples with very large households so estimating the quantiles for those
groups is increasingly noisy.

3.8 In the data from the 1996 SIPP panel
a) What proportion of households received any "means-tested cash benefits"
(`thtrninc`)? For those households that did receive benefits what mean
proportion of their total income came from these benefits?


```{r 38a}
db <- DBI::dbConnect(RSQLite::SQLite(), "Data/SIPP/sipp.db")
sipp_df <- tbl(db, sql("SELECT * FROM household")) %>%
  dplyr::collect() %>%
  select(ghlfsam, gvarstr, whfnwgt, thtotinc, thtrninc, tmthrnt) %>%
  mutate(
    benefit_recipient = I(thtrninc > 0) * 1,
    thtrninc = as.numeric(thtrninc),
    tmthrnt = as.numeric(tmthrnt)
  )

sipp_hh_sub <- sipp_df %>%
  as_survey_design(
    id = ghlfsam, strata = gvarstr, nest = TRUE,
    weight = whfnwgt
  )
sipp_hh_sub %>%
  summarize(prop_benefit_recipients = survey_mean(benefit_recipient))
```

```{r 38a_2}
sipp_hh_sub %>%
  filter(benefit_recipient == 1) %>%
  mutate(prop_benefit_income = thtrninc / thtotinc) %>%
  summarize(
    mn_prop_benefit_income = survey_mean(prop_benefit_income)
  )
```


b) What proportion of households paid rent `tmthrnt`? What were the mean and the
75th and 95th percentiles of the proportion of monthly income paid in rent?
What proportion paid more than one third of their income in rent?

```{r 38b}
sipp_hh_sub %>%
  mutate(
    pays_rent = I(as.numeric(tmthrnt) > 0) * 1,
    pct_income_rent = (tmthrnt / thtotinc) * 100,
    rent_pct_gt_thrd = (pct_income_rent > 0.33) * 1
  ) %>%
  # avoid divide by zero error
  filter(thtotinc > 0) %>%
  summarize(
    prop_pays_rent = survey_mean(pays_rent),
    mean_pct_income_rent = survey_mean(pct_income_rent, na.rm = TRUE),
    quantile_pct_income_rent = survey_quantile(pct_income_rent,
      na.rm = TRUE,
      quantiles = c(.75, .95)
    ),
    prop_rent_gt_thrd = survey_mean(rent_pct_gt_thrd, na.rm = TRUE)
  ) %>%
  pivot_longer(cols = everything(), names_to = "Rent", values_to = "Estimates")
```


3.9 By the time you read this, the `survey` package is likely to provide some
approximations for PPS designs that use the finite population size information.
Repeat 3.2 using these.

```{r 39_simulated_pps}
OneSimulation <- function() {
  insample <- sampling::UPtille(election$p)
  ppsample <- election[insample == 1, ]
  ppsample$wt <- 1 / ppsample$p
  pps_design <- svydesign(id = ~1, weight = ~wt, data = ppsample, pps = "brewer")
  total <- svytotal(~ Bush + Kerry + Nader, pps_design)
  std_err <- sqrt(diag(attr(total, "var")))
  ci <- confint(total)
  out <- cbind(total, std_err, ci)
}
total_sims <- replicate(10, OneSimulation())
```

a) Check that the mean of the estimated totals is close to the true population 
totals.

```{r 39_fpcpps}
OneSimulation <- function() {
  insample <- sampling::UPtille(election$p)
  ppsample <- election[insample == 1, ]
  ppsample$wt <- 1 / ppsample$p
  ppsample$fpc <- 40 / sum(election$votes)
  pps_design <- svydesign(id = ~1, weight = ~wt, fpc = ~fpc, data = ppsample, pps = "brewer")
  total <- svytotal(~ Bush + Kerry + Nader, pps_design)
  std_err <- sqrt(diag(attr(total, "var")))
  ci <- confint(total)
  out <- cbind(total, std_err, ci)
}
total_sims <- replicate(10, OneSimulation())
```

```{r 39_fpc_pps_totals}
estimated_totals <- as_tibble(t(rowMeans(total_sims[, 1, ]))) %>%
  mutate(label = "Estimate")

true_totals <- as_tibble(t(colSums(election[, c("Bush", "Kerry", "Nader")]))) %>%
  mutate(label = "Truth")

rbind(estimated_totals, true_totals) %>%
  gather(everything(), -label, key = "Candidate", value = "Vote Count") %>%
  spread(label, `Vote Count`) %>%
  gt::gt() %>%
  gt::fmt_scientific() %>%
  gt::tab_header("Simulated Total Comparison")
```

These are quite close.

b). Compute the mean of the estimated standard errors and compare it to the
true simulation standard error, that is, the standard deviation of the 
estimated totals.

```{r 39_pps_stderrs, eval = FALSE}
estimated_stderrs <- as_tibble(t(rowMeans(total_sims[, 2, ]))) %>%
  mutate(label = "Estimate")

true_stderr <- as_tibble(apply(total_sims, 1, sd)) %>%
  mutate(label = "Truth", Candidate = c("Bush", "Kerry", "Nader")) %>%
  spread(Candidate, value)

rbind(estimated_stderrs, true_stderr) %>%
  gather(everything(), -label, key = "Candidate", value = "Vote Std.Err") %>%
  spread(label, `Vote Std.Err`) %>%
  gt::gt() %>%
  gt::fmt_scientific() %>%
  gt::tab_header("Simulated Standard Error Comparison")
```

Estimate 95% confidence intervals for the population totals and compute the 
proportion of intervals that contain the true population value.

```{r 39_pps_cis, eval = FALSE}
totals <- unlist(true_totals[, 1:3])
prop_contained <- rowMeans((total_sims[, 3, ] < totals &
  total_sims[, 4, ] > totals) * 1)
prop_contained
```

3.10 Repeat 3.2 computing the Hartley-Rao approximation and the full 
Horvitz-Thompson estimate using the code and joint-probability data on the web
site. Compare the standard errors from these two approximations to the standard
errors from the single-stage with replacement approxmiation and to the true
simulation standard error.

```{r 310}
```

3.11 Since 1999, NHANES has been conducting surveys continuously with data 
released on a 2 year cycle. Each data set includes a weight variable for
analyzing the two-year data; the weights add to the size of the US adult, 
civilian, non-institutionalized population.

a) What weight would be appropriate for estimating the number of diabetics in
the population combining data from two two-year data sets?

* Assuming these are non-overlapping samples --- which seems reasonable
--- and considering the target population we're generalizing to to be 
roughly constant over the 4 years of interest, we could divide each of the 
previous weights in half. This would give us twice the sample size to estimate
the same target estimand.

b) What weight would be appropriate if three two-year data sets were used?

c) What weights would be appropriate when estimating changes, comparing
the combined 1999-2000 and 2001-2002 data with the combined 2003-2004 and 
2005-2006 data?

d) How would the answers differ if the goal was to estimate a population 
proportion rather than a total?


# Chapter 4: Graphics

Lumley advocates for three principles in visualizing survey data:

1.  Base the graph on an estimated population distribution.

2.  Explicitly indicate weights on the graph.

3.  Draw a simple random sample from the estimated population distribution and
    graph this sample instead.

All three of these strategies are meant to counteract the difficulty in
visualizing survey data --- the data available do not represent the population
of interest without re-weighting.

While these principles are great and worth following, I found Lumley's
demonstrations in this chapter a little out of date. Thanks to the
[ggplot](https://ggplot2.tidyverse.org/) family of libraries and
[shiny](https://www.rstudio.com/products/shiny/) there's been huge advances in
visualizing and interacting with data of all types -- survey included. What's
more, it isn't always clear how he produces the charts in the chapter.
Consequently I've done my best to reproduce the same charts, or a chart I'd
consider appropriate for the question / survey at hand in the following charts.

TODO: Talk about ggsurvey.

## Plotting a Table

Lumley recommends using bar charts, forest plots and fourfold plots to visualize
the data from a table. I would agree that all of these are "fine" in a certain
context but strongly prefer the forest plot and variations on it personally,
since it does more than all the other to include representations of uncertainty
about the tabulated estimates.

```{r barplot_medians}
medians %>%
  ggplot(aes(x = racehpr, y = Median_BMI, fill = srsex)) +
  geom_bar(stat = "identity", position = "dodge") +
  ylab("Median BMI (kg/m^2)") +
  xlab("") +
  theme(
    legend.title = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 0.25, hjust = .25)
  ) +
  ggtitle("Median BMI Across Race, Sex")
```

```{r forestplot_medians}
medians %>%
  ggplot(aes(x = Median_BMI, y = racehpr, color = srsex)) +
  geom_pointrange(aes(xmin = Median_BMI_low, xmax = Median_BMI_upp),
    position = position_dodge(width = .25)
  ) +
  geom_vline(aes(xintercept = 25), linetype = 2, color = "red") +
  xlab("BMI") +
  ylab("") +
  theme(legend.title = element_blank(), legend.position = "top") +
  ggtitle("Median BMI by Race/Ethnicity and gender, from CHIS") +
  labs(caption = str_c(
    "Line indicates CDC border between healthy and ",
    "overweight BMI."
  ))
```

## One Continuous Variable

Lumley argues that the most straightforward graphical displays for a single
continuous variable are boxplots, cumulative distribution function (cdf) plots 
and survival curves. I think histograms are also useful but we'll get to that
shortly.

Below I reproduce Figure 4.6 from the text
in which Lumley demonstrates the difference between the weighted and unweighted
CDF's of the California school data demonstrating that, indeed, the design 
based estimate is closer to the population value than the unweighted, naive
estimate of the stratified design. This should all intuitively make sense.
My only complaint would be that the uncertainty of the cdf isn't visualized
when that should be just as easily accessible. I made a cursory investigation
to see if these data were available in the `svycdf` object but they were not. 


```{r svycdf}
cdf.est <- svycdf(~ enroll + api00 + api99, dstrata)

cdf.pop <- ecdf(apipop$enroll)

cdf.samp <- ecdf(apistrat$enroll)

par(mar = c(4.1, 4.1, 1.1, 2.1))

plot(cdf.pop,
  do.points = FALSE, xlab = "enrollment",
  ylab = "Cumulative probability",
  main = "Cumulative Distribution of California School Size",
  sub = "Reproduces Lumley Fig 4.6", lwd = 1
)

lines(cdf.samp, do.points = FALSE, lwd = 2)
lines(cdf.est[[1]],
  lwd = 2, col.vert = "grey60", col.hor = "grey60",
  do.points = FALSE
)
legend("bottomright",
  lwd = c(1, 2, 2), bty = "n",
  col = c("black", "grey60", "black"),
  legend = c("Population", "Weighted estimate", "Unweighted Estimate")
)
```
Next Lumley plots an adjusted 
[kaplan meier](https://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator) 
curve using `svykm()` on the National Wilms Tumor Study data. Unfortunately
he doesn't show how to create the design object and I find no mention of it
elsewhere in the book. I made a guess and it seems to be accurate. Note
that I obtained the national wilms tumor study data from the [`survival`](https://cran.r-project.org/web/packages/survival/index.html) 
package.

```{r svykm}
dcchs <- svydesign(ids = ~1, data = nwtco)
scurves <- svykm(Surv(edrel / 365.25, rel) ~ histol, dcchs)
plot(scurves)
```
The interpretation of this graph is that relapse (into cancer) appears to 
occur within about three years, if at all. The top line shows the survival
for those with a favorable histology classification with an even better
survival rate.

Lumley makes a note here describing how the sampling weights make a 
large difference in the estimate because the design is a case cohort sample.
That being said, I don't really see the difference when I compare his figure
to mine created with an equal probability sample... An error here perhaps.


#### Boxplots

Lumley describes the typical boxplots as

> based on the quartiles of the data: the box shows the median and first and 
third quartiles, the whiskers extend out to the last observation within 1.5
interquartile ranges of the box ends, and all points beyond the whiskers are 
shown individually.


This is as good a summary as any, I'll only note that the median is the line 
within the interior of the box and the first and third quartile define the 
boundaries of the box. It's (somewhat) easy to image how Lumley estimates
these values, as he has already introduced the `svyquantile()` function ---
this should be a straightforward application of that function.

I reproduce Figure 4.10 from the text using the nhanes data and design object
created in answering the questions for chapter 3. His code is equivalent.

```{r boxplots}
## Lumley's code
# nhanes <- svydesign(id = ~SDMVPSU, strat = ~SDMVSTRA,
#                    weights = ~WTMEC2YR, data = both, nest = TRUE)

## I use the bpdf design from the chapter 3 questions
nhanes <- bpdf_design %>%
  mutate(
    age_group = cut(RIDAGEYR, c(0, 20, 30, 40, 50, 60, 80, Inf)),
  )
svyboxplot(BPXSAR ~ age_group, subset(nhanes, BPXSAR > 0),
  col = "gray80",
  varwidth = TRUE, ylab = "Systolic BP (mmHg)", xlab = "Age"
)
```
The plot shows the distribution in blood pressure across the different age 
groups. I already showed how I visualized this previously, but it is nice
to know how to do something multiple ways. In general, our observation shows
an increase in systolic blood pressure medians and third quartiles across age.


#### Graphs based on the density

Histograms and kernel density estimators both visualize the probability
distribution function(pdf) of a given dataset. Confusingly, perhaps, there 
is no pdf to estimate in finite population inference because the sampling
is random instead of the data. Still, the analogous effort can be made where
a given proportion is estimated for some number of bins of the variable of 
interest. Instead of estimating a naive proportion, there's now a sample based
proportion. I reproduce Lumley's Figure 4.12 below demonstrating how this 
works.

```{r svyhist}
svyhist(~BPXSAR, subset(nhanes, RIDAGEYR > 20 & BPXSAR > 0),
  main = "",
  col = "grey80", xlab = "Systolic BP (mmHg)"
)
lines(svysmooth(~BPXSAR, nhanes,
  bandwidth = 5,
  subset = subset(nhanes, RIDAGEYR > 20 & BPXSAR > 0)
), lwd = 2)
```

This looks considerably different then the naive estimate, again showcasing
the need for taking the design into account.

```{r naive_hist}
hist(bpdf_design$variables$BPXSAR,
  xlab = "Systolic BP (mmHg)",
  main = "Naive Distribution of Blood Pressure"
)
```


#### Two Continuous Variables

Where the design could be used to adjust the raw sample summaries to adjust
for the design with one variable, two variable visualizations make this much
more difficult as there is no way to incorporate the design information into
the presented estimate. An additional dimension has to be used to illustrate
the design information.


#### Scatterplots


To that end, Lumley uses a bubbleplot with the size of the "bubbles" 
proportional to the sampling weight. This way, the viewer can identify which 
points should be considered as "more" or less impactful in terms of representing 
the population. I reproduce part of Figures 4.13 - 4.15 from the text below, 
for those plots in which Lumley includes the code. plots the systolic and 
diastolic blood pressure from the NHANES design.


```{r}
# TODO(petersonadam): Try plotting the api data here too
par(mfrow = c(1, 2))
svyplot(BPXSAR ~ BPXDAR,
  design = nhanes, style = "bubble",
  xlab = "Diastolic pressure (mmHg)",
  ylab = "Systolic pressure (mmHg)"
)
svyplot(BPXSAR ~ BPXDAR,
  design = nhanes, style = "transparent",
  pch = 19, alpha = c(0, 0.5),
  xlab = "Diastolic pressure (mmHg)",
  ylab = "Systolic pressure (mmHg)"
)
```

As Lumley notes, this is a case in which the sampling weights --- bubble size 
--- is not particularly informative, as we don't see any particularly obvious 
pattern relating the size of the bubbles to the two variables of interest. 
Turning to the shading plot, though we can now see more than just the "blob"
in the first plot, there's still no apparent pattern between the 
bubble size and the two variables to identify.

Below, I include Lumley's "subsample" method, which draws a simple random
sample from the target population by using the provided sampling probabilities.
Lumley reccomends looking at 2 or three iterations of a subsample plot
in order to ensure that any features visualized are not "noise" from the 
sampling process.

```{r subsample}
svyplot(BPXSAR ~ BPXDAR,
  design = nhanes, style = "subsample",
  sample.size = 1000,
  xlab = "Diastolic pressure (mmHg)",
  ylab = "Systolic pressure (mmHg)"
)
```
#### Aggregation and smoothing

While less of an issue than it was at the time of Lumley's writing, 
aggregating and smoothing across points makes it easier to condense the
number of sample points in a visualization to reduce the memory required to
visualize all the points in the sample. In a design setting it also provides
an opportunity to incorporate the design information into a visualization
specific estimate.


Lumley's first example of this is a hexplot - a plot where a grid of hexagons
is created and sized according to the number of points within the hex-bin.

```{r hexplot}
svyplot(BPXSAR ~ BPXDAR,
  design = nhanes, style = "hex", legend = 0,
  xlab = "Diastolic pressure (mmHg)",
  ylab = "Systolic pressure (mmHg)"
)
```

This is perhaps the best visualization of the data thus far, where the "blob"
is still apparent but outliers are still visible and a more concise summary
of the data is easily visible.


#### Scatterplot smoothers

Lumley next describes how to take the discrete estimates examining blood
pressure as a function of age and smooth them when both variables are 
continuous. The code below shows how to do this by using the `svyplot()` 
function using quantile regression methods from the 
[`quantreg`](https://cran.r-project.org/web/packages/quantreg/index.html) 
package. Mean estimates can also be obtained by using `method = 'locpoly'`.


```{r scatterplot_smoother}
adults <- subset(nhanes, !is.na(BPXSAR))
a25 <- svysmooth(BPXSAR ~ RIDAGEYR,
  method = "quantreg", design = adults,
  quantile = .25, df = 4
)
a50 <- svysmooth(BPXSAR ~ RIDAGEYR,
  method = "quantreg", design = adults,
  quantile = .5, df = 4
)
a75 <- svysmooth(BPXSAR ~ RIDAGEYR,
  method = "quantreg", design = adults,
  quantile = .75, df = 4
)
a10 <- svysmooth(BPXSAR ~ RIDAGEYR,
  method = "quantreg", design = adults,
  quantile = .1, df = 4
)
a90 <- svysmooth(BPXSAR ~ RIDAGEYR,
  method = "quantreg", design = adults,
  quantile = .9, df = 4
)
plot(BPXSAR ~ RIDAGEYR,
  data = nhanes, type = "n", ylim = c(80, 200),
  xlab = "Age", ylab = "Systolic Pressure"
)
lines(a50, lwd = 3)
lines(a25, lwd = 1)
lines(a75, lwd = 1)
lines(a10, lty = 3)
lines(a90, lty = 3)
legend("topleft",
  legend = c("10%,90%", "25%, 75%", "median"),
  lwd = c(1, 1, 3), lty = c(3, 1, 1), bty = "n"
)
```

#### Conditioning Plots

A conditioning plot is effectively a scatter plot with a third 
variable fixed. This third variable is then displayed in the facet title of the 
plot. In Lumley's text he shows how to do this using a call to the 
`svycoplot()` function to recreate the top half of Figure 4.20. Of note,
the additional `hexscale` argument can be fed the `"absolute"` argument to
make the scales comparable between panels - by default the scales are
facet specific, though the data (for a continuous facet) has a ~50% overlap so
the scales are not dramatically different.


```{r svycoplot}
svycoplot(BPXSAR ~ BPXDAR | equal.count(RIDAGEMN),
  style = "hex", # or "transparent" for shaded hexs,
  # hexscale = "absolute" # for fixed scales across facets.
  design = subset(nhanes, BPXDAR > 0), xbins = 20,
  strip = strip.custom(var.name = "AGE"),
  xlab = "Diastolic pressure (mm Hg)",
  ylab = "Systolic pressure (mm Hg)"
)
```

## Maps

### Design and Estimation Issues

The final section in this chapter looks at how to visualize survey data 
spatially across a map. Since many surveys contain geographic information
in both their sampling design and the questions they seek to answer, it 
makes sense that one might want to visualize estimates at some geographic
scale.

Lumley uses the `maptools` R package to take estimates computed
using techniques/functions already demonstrated and visualize them on maps.

Since maptools isn't available on CRAN at the current time of writing, I'll
use the [sf package](https://r-spatial.github.io/sf/) and `ggplot2`.


Below I reproduce Figure 4.21 from the text using these packages with
the same design based estimates in the text. The data was procured from
Lumley's [website](https://r-survey.r-forge.r-project.org/svybook/) --- 
search for "BRFSS".

```{r}
states <- read_sf("Data/BRFSS2007/brfss_state_2007_download.shp") %>%
  arrange(ST_FIPS)
bys <- svyby(~X_FRTSERV, ~X_STATE, svymean,
  design = subset(brfss, X_FRTSERV < 99999)
)
state_fruit_servings <- states %>%
  select(ST_FIPS) %>%
  st_drop_geometry() %>%
  left_join(bys, by = c("ST_FIPS" = "X_STATE")) %>%
  mutate(geometry = states$geometry) %>%
  st_as_sf()

state_fruit_servings %>%
  ggplot() +
  geom_sf(aes(fill = X_FRTSERV / 100)) +
  theme_void() +
  theme(legend.title = element_blank()) +
  ggtitle("Servings of fruit per day, from BRFSS 2007")
```


```{r brfss_fruit_age}
hlth <- brfss %>%
  as_survey_design() %>%
  mutate(
    agegp = cut(AGE, c(0, 35, 50, 65, Inf)),
    state = X_STATE,
    covered = (HLTHPLAN == 1) * 1
  ) %>%
  group_by(agegp, state) %>%
  summarize(
    health_coverage = survey_mean(covered)
  ) %>%
  ## Formatting
  mutate(Age = case_when(
    agegp == "(0,35]" ~ "<35",
    agegp == "(35,50]" ~ "35-50",
    agegp == "(50,65]" ~ "50-65",
    agegp == "(65,Inf]" ~ "65+"
  ))



insurance_coverage <- states %>%
  select(ST_FIPS, geometry) %>%
  left_join(hlth, by = c("ST_FIPS" = "state")) %>%
  st_as_sf()

insurance_coverage %>%
  ggplot(aes(fill = health_coverage)) +
  geom_sf() +
  facet_wrap(~Age) +
  theme_void() +
  theme(legend.title = element_blank())
```

Lumley then shows two plots with insurance coverage at the state level. 
Looking at the 
[code](https://r-survey.r-forge.r-project.org/svybook/maps-webpage.R) he posted
on the web it isn't clear to me what he's estimating that's different here as
I don't see any calls to any of the survey functions. Consequently,
I've just created some fake simulated data and created a plot with the 
equivalent data.

```{r city_data}
cities <- read_sf("Data/BRFSS2007/BRFSS_MMSA_2007.shp") %>%
  filter(NAME != "Columbus") %>%
  transmute(Insurance = cut(rbeta(n(), 1, 1), c(0, 0.25, .5, .75, 1)))

marginal_insurance <- brfss %>%
  as_survey_design() %>%
  mutate(
    covered = (HLTHPLAN == 1) * 1,
    state = X_STATE,
  ) %>%
  group_by(state) %>%
  summarize(
    health_coverage = survey_mean(covered)
  ) %>%
  ungroup()

map_data <- states %>%
  select(ST_FIPS, geometry) %>%
  left_join(marginal_insurance, by = c("ST_FIPS" = "state")) %>%
  st_as_sf()

ggplot() +
  geom_sf(data = map_data, aes(fill = health_coverage)) +
  geom_sf(data = cities, aes(color = Insurance)) +
  theme_void() +
  theme(legend.title = element_blank()) +
  ggtitle("Insurance Coverage - from BRFSS and Fake Data")
```

## Questions

1. Draw boxplots of body mass index by race/ethnicity and by sex using the 
CHIS 2005 data introduced in Chapter 2.

```{r chis_bmi_race}
svyboxplot(bmi_p ~ racehpr, chis, main = "BMI By Race/Ethnicity")
```

```{r chis_bmi_sex}
svyboxplot(bmi_p ~ srsex, chis, main = "BMI BY Sex")
```

2. Using the code in Figure 3.8 draw a barplot of the quantiles of income
and compare it to the dotchart in Figure 3.9. What are some advantages and
disadvantages of each display.

```{r}
```

3. Use `svysmooth()` to draw a graph showing change in systolic and diastolic
blood pressure over time in the NHANES 2003-2004 data. Can you see the change
to isolated systolic hypertension in old age that is shown in Figure 4.5.

```{r}
plot(svysmooth(BPXSAR ~ RIDAGEYR, nhanes))
```


4. With the data from the SIPP 1996 panel draw the cumulative distribution 
function  densityfunction, a histogram and a boxplot of total household income.
Compare these graphs for their usefulness in showing the distribution of
income.

```{r}
```

5. With the data from the SIPP 1996 panel draw a graph showing amount of rent 
(`tmthrent`)  and proportion of income paid to rent. You will want to exclude
some outlying households that report much higher rent than income.

6. Using data from CHIS 2005 (see section 2.3.1) examine how body mass index
varies with age as we did with blood pressure in this chapter.

```{r}
plot(svysmooth(bmi_p ~ srage_p, chis),
  xlab = "Age", ylab = "BMI",
  main = "BMI vs. Age (CHIS data)"
)
```

We see a very distinctive U-shape - with middle aged indviduals - 50 to 60 year
olds - having the highest average BMI, but the young and old having lower
BMI's.

7. The left-hand panel of Figure 3.3 shows an interesting two-lobed pattern. 
Can you find what makes these lobes?

8. Set up a survey design for the BRFSS 2007 data as in Figure 3.7. BRFSS
measured annual income (`income2`) in categories < \$10K, \$10-15k \$20-25k,
\$25-35k, \$35-50k, \$50-75k, > \$75k and race (`orace`) :white,black, asian,
native hawaiian/pacific island, native american, other.

* Draw a graph of income by race.
* Draw maps showing the geographical distribution of income and of racial 
groups.
* Draw a set of maps examining whether the geographical distribution of income
differs by race.

9. Explore the impact on the graphs in Figure 4.18 of changes in the amount of 
smoothing, by altering the `df` argument to the code in Figure 4.19

# Chapter 5: Ratios and Linear Regression

Lumley identifies two main uses for regression in analyzing complex surveys:

1.  Identifying relationships between variables --- similar to any other data.
2.  More accurate estimates of population means and totals.

In contrast to model based inference which typically discusses linear regression
in the context of distributional assumptions on the outcome variable, Lumley
notes that his discussion of regression is still within the design-based
philosophy and consequently no model based assumptions are needed in order to
compute valid 95% confidence intervals. However, model choice still matters
insofar as one's goal is to precisely estimate a relationship or population mean
or total.

In statistical parlance, Lumley is using 
[GEE](https://en.wikipedia.org/wiki/Generalized_estimating_equation) - 
or generalized estimating equations to fit models, which only require
assumptions about the moments of the underlying data distribution, rather than
the family of the distribution.

My take is that this approach also allows for more flexibility in how the 
variance of the model can be estimated. Since the variance associated with a 
complex design is a function of the design itself, GEE makes it easier
to structure the estimating equations in such a way that the variance
computation corresponds to the design. In fact, Lumley explicitly notes 
in section 5.2.1 that the heteroskedastic / 
[sandwhich based variance estimators](https://stats.stackexchange.com/questions/50778/sandwich-estimator-intuition)
which came out of GEE are used by the `survey` package, with special
handling for combining variance within/across strata.


## Ratio Estimation

Ratio estimation comes up first in this chapter because it is important in
estimating (1) a population mean/total, (2) a ratio directly or (3) a
subpopulation estimate of a mean.

Lumley illustrates how to estimate ratios in design methods by using the api
dataset and estimating the proportion of students who took the Academic
Performance Index exam.

```{r ratio_estimate}
svyratio(~api.stu, ~enroll, strat_design)
```

This estimate does a good job of estimating the true population total,
`r round(sum(apipop$api.stu) / sum(apipop$enroll, na.rm = TRUE), 2)`, which we
happen to have access to for this example.

It's worth noting here as Lumley does that ratio estimates are not unbiased but
are classified as "approximately unbiased" since the bias decreases proportional
to the sample size and is consequently smaller than the standard error -- which
decreases proportional to $\frac{1}{\sqrt{n}}$.

### Ratios for subpopulation estimates

In the case where individual - not aggregate - data are
available the ratio being estimated is simply a proportion. This is the same
logic for which subpopulation estimates had been calculated previously in
[Chapter 2:Simple Random Sample] via the `svyby()` function. These estimates
require special handling - though in the survey package they can all be
calculated via `svymean()`, `svyratio()` and `svycontrast()` which I show below
using the same designe object from Chapter 2.

It is worth noting before doing so however, that the special handling needed
here follows from the fact that both the numerator and the denominator are
estimated. Lumley delves into this in the appendix which I'll reproduce here
alongside questions I have that I'll look to return to in the future.

#### A brief aside on ratio variance estimation

We'll define the subpopulation estimate of interest using the indicator function
$Y_i = X_iI(Z_I > 0)$, where $I(Z_i > 0) = 1$ for members of the subpopulation
and 0 otherwise, and $X_i$ is the measurement of interest.

The variance estimate using replicate weights can be calculated similar to the
typical variance estimate, those replicate weights belonging to sample
observations outside the subpopulation are simply not used - this again
highlights the utility of replicate weights.

For linearization - that is using a taylor series to estimate the variance - the
value becomes more complicated, following Lumley's appendix the HTE is defined
as:

$$
\hat{V}[\hat{T}_Y] = \sum_{i,j} \left(\frac{Y_i Y_j}{\pi_ij} - 
\frac{Y_i}{\pi_i} \frac{Y_j}{\pi_j} \right) \\
= \sum_{Z_i,Z_j > 0} \left(\frac{Y_i Y_j}{\pi_ij} - 
\frac{Y_i}{\pi_i} \frac{Y_j}{\pi_j} \right).
$$

Here however, Lumley states

> but the simplified computational formulas for special designs are not the
> same.

which I don't completely understand. I suppose he means for clustered or
multiphase designs things but it isn't clear as he goes onto say

> for example, the formula for the variance of a total under simple random
> sampling (equation 2.2)

$$
V[\hat{T}_X] = \frac{N-n}{N} \times N^2 \times \frac{V[X]}{n}
$$

> cannot be replaced by

$$
V[\hat{T}_Y] \stackrel{?}{=} \frac{N-n}{N} \times N^2 \times \frac{V[X]}{n}
$$

> or even, defining $n_D$ as the number sampled in the subpopulation, by

$$
\stackrel{?}{=} \frac{N-n_D}{N} \times N^2 \times \frac{V[X]}{n_D}
$$

> In order to use these simplified formulas it is necessary to work with the
> variable $Y$ and use

$$
V[\hat{T}_Y] = \frac{N-n}{N} \times N^2 \times \frac{V[Y]}{n}
$$

Its not clear in this last expression if we're simply back to the initial
expression that couldn't be used, or if we're using the smaller sample subset
again for variance computations but Lumley's next text suggests that's the case:

> Operationally, this means that variance estimation in a subset of a survey
> design object in R needs to involve the $n - n_D$ zero contributions to an
> estimation equation.

I hope to shed more light on what's going on here in the future but for now its
clear why this is in the appendix, but not exactly clear to me why observations
outside the subpopulation are *simply* zero'd in variance computation.

Lumley uses the following three function calls to illustrate three different
ways to estimate a ratio (1) A call to `svymean()`, (2) A call to `svyratio()`
and (3) \`

```{r ratio_subpop_one}
svymean(~bmi_p, subset(chis, srsex == "MALE" & racehpr == "AFRICAN AMERICAN"))
```

```{r ratio_subpop_two}
chis <- update(chis,
  is_aamale = (srsex == "MALE" & racehpr == "AFRICAN AMERICAN")
)
svyratio(~ I(is_aamale * bmi_p), ~is_aamale, chis)
```

```{r ratio_subpop_three}
totals <- svytotal(~ I(bmi_p * is_aamale) + is_aamale, chis)
totals
svycontrast(
  totals,
  quote(`I(bmi_p * is_aamale)` / `is_aamaleTRUE`)
)
```

### Ratio estimators of totals

The third use Lumley lists for the use of ratio estimators is to construct more
accurate estimates of population means or totals. His motivating example is to
take the ratio estimate of individuals who took the API tests and then use that
to determine the approximate number of students who took the test, by
multiplying the ratio estimate by the number of students. This can be done by
hand or via the survey package `predict()` function used in conjunction with
`svyratio()`.

```{r ratios_for_totals}
r <- svyratio(~api.stu, ~enroll, strat_design)
predict(r, total = sum(apipop$enroll, na.rm = TRUE))
```

Lumley uses this as a jumping off point to discuss linear regression since 
one can imagine the relationship between the number of students taking the API
test as being roughly proportional to the number of students enrolled at the
schools; $E[tests_i] = \alpha \times \text{enrollment}_i + \epsilon_i$ where
$E[\epsilon] = 0$ (note that this is an assumption about the moment of the error
distribution and not the shape of the error distribution itself).

## Linear Regression

A quick review of the moment assumptions for linear regression - which is all
that are needed for designed based estimation. 

If we have random response variable $Y$ and explanatory variable $X$ then linear
regression is looking at the relationship between the expectation of $Y$ and 
$X$:
$$
E[Y] = \alpha + X \beta,
$$

Where $\alpha$ is a constant offset, also called the intercept and $\beta$ is
the slope coefficient that describes the change in $E[Y]$ per unit change in 
$X$. Here I'm referring to $X$ and $\beta$ as singular variables but they
could also be a matrix and vector of explanatory variables and slope 
coefficients, respectively. The variance of the response variable, $Y$ is 
assumed to be constant, i.e. $V[Y] = \sigma^2$, unless otherwise modeled.

Following the standard OLS estimation procedure, we'd normally 
minimize the squared error and Lumley notes that if we have the complete 
population data, we'd be finished at that:

$$
RSS = \sum_{i=1}^{N} (Y_i - \alpha X_i\beta)^{2}.
$$

Given that we're typically dealing with (complex) samples though, we have
to adjust the estimates to account for the weighting:


$$
\hat{RSS} = \sum_{i=1}^{n} \frac{1}{\pi_i}(Y_i - \alpha - X_i \beta)^2,
$$

so each error term is up weighted according to its sampling probability.
 

### Regression Estimation of Population Totals

Lumley's ratio estimator of a population total described previously derives 
from the linear regression model with a single predictor and no intercept. 
The *separate ratio estimator*, similar to the 
[cell means model](https://online.stat.psu.edu/stat502/lesson/4/4.3) 
estimates a ratio for each stratum and the estimate of the total is the 
sum of the denominator for all strata. Formally,

$$
E[Y_i] = \beta_k \times X_i \times \{i \in \text{ stratum } k\},
$$

where $\beta_k$ is the ratio for stratum $k$ estimates the given quantity. This
setup can provide more precise estimates than the single ratio estimator when
the sample size gets large and the strata are able to better explain the outcome
variable. However, if the strata don't have any correlation with the outcome
then the standard errors increase, due to the need to estimate the extra
parameters.


THIS EXAMPLE DOESN'T MAKE COMPLETE SENSE.
Lumley illustrates this latter phenomenon with the California school data - 
using the percentage of english language learners as a predictor of the 
overall number of students taking the api tests.


```{r separate_ratio_estimator}
sep <- svyratio(~api.stu, ~enroll, strat_design, separate = TRUE)
com <- svyratio(~api.stu, ~enroll, strat_design)
stratum_totals <- list(E = 1877350, H = 1013824, M = 920298)
predict(sep, total = stratum_totals)
```

```{r common_ratio_estimator}
predict(com, total = sum(unlist(stratum_totals)))
```
We see the common ratio has a smaller standard error than the separate ratio
estimator.


```{r ratio_api_stu}
svyby(~api.stu, ~stype, design = dstrata, denom = ~enroll, svyratio)
```

**Incomes in Scotland**

Lumley works through an example looking at household incomes across Scotland
from their national household survey. Unfortunately both the dataset subset he 
provides at his [website](https://r-survey.r-forge.r-project.org/svybook/) to 
and the full dataset he [links to](https://www.restore.ac.uk/PEAS/exemplar2.php)
don't have the variables he uses in his example code in Figure 5.7. For 
example the code he provides is filtered using an ADULTH variable which isn't 
found in either dataset.

```{r scotland_incomes}
load("Data/SHS/shs.rda") # Lumley's website data
colnames(shs$variables)
load("Data/SHS/ex2.RData") # PEAS "full Data" website
colnames(shs)
```

Consequently, I won't reproduce this example here, except to say that he uses
the example to illustrate how oversampling certain strata (poorer households)
can improve the precision associated with the household income estimate and
that using the population information increased the precision of the weekly
household income estimate via linear regression -- for those sub-populations for
which population information is available.


**US Elections**

Similarly it doesn't look like the dataset included in the current `survey` R
package has data for the 2008 election - I only see Bush / McCain vote totals.


```{r election_colnames}
data(elections)
colnames(election)
```

Consequently I can't do the analysis he shows predicting 2008 votes
using 2000 votes. It'll hopefully suffice to say that in theme with the
content for the chapter, that because these values are correlated ---
2000 vote % for republican candidate and 2008 vote % for republican candidate 
--- it stands to reason that we can reduce the variance of the resulting
estimate rather than using the 2008 data alone.


### Confouding and other criteria for model choice

Lumley describes three categories for describing why a predictor might be 
included in a regression, noting that this may help the model fit better and
thus aid in reducing bias from a probability sample that results from, say
non-response.

1. Exposure of interest: If we're interested in a specific variable's impact
on a variable, it makes sense to include that in a model to estimate the
relationship.

2. Confounding variables: A variable may not be of primary interest, but may
be associated with both the outcome variable and exposure of interest. 
Consequently, this will need to be *adjusted for* in order to isolate the 
effect of interest.

3. Precision variables: These are, again, associated with the outcome variable
of interest, but not associated with the exposure of interest. However, 
because of their association alone, they can increase the precision with
which the exposure effect is estimated.

Lumley goes on to describe methods for model selection which I'll leave for the
text.


### Linear models in the `survey` package


**Example:Dietary sodium and potassium and blood pressure**


```{r sodium_nhanes_merge}
demo <- haven::read_xpt("data/nhanesxpt/demo_c.xpt")[, c(1:8, 28:31)]
bp <- haven::read_xpt("data/nhanesxpt/bpx_c.xpt")
bm <- haven::read_xpt("data/nhanesxpt/bmx_c.xpt")[, c("SEQN", "BMXBMI")]
diet <- haven::read_xpt("data/nhanesxpt/dr1tot_c.xpt")[, c(1:52, 63, 64)]
nhanes34 <- merge(demo, bp, by = "SEQN")
nhanes34 <- merge(nhanes34, bm, by = "SEQN")
nhanes34 <- merge(nhanes34, diet, by = "SEQN")

demo5 <- haven::read_xpt("data/nhanesxpt/demo_d.xpt")[, c(1:8, 39:42)]
bp5 <- haven::read_xpt("data/nhanesxpt/bpx_x.xpt")

bp5$BPXSAR <- rowMeans(bp5[, c("BPXSY1", "BPXSY2", "BPXSY3", "BPXSY4")],
  na.rm = TRUE
)
bp5$BPXDAR <- rowMeans(bp5[, c("BPXDI1", "BPXDI2", "BPXDI3", "BPXDI4")],
  na.rm = TRUE
)
bm5 <- haven::read_xpt("data/nhanesxpt/bmx_d.xpt")[, c("SEQN", "BMXBMI")]
diet5 <- haven::read_xpt("data/nhanesxpt/dr1tot_d.xpt")[, c(1:52, 64, 65)]


nhanes56 <- merge(demo5, bp5, by = "SEQN")
nhanes56 <- merge(nhanes56, bm5, by = "SEQN")
nhanes56 <- merge(nhanes56, diet5, by = "SEQN")

nhanes <- rbind(nhanes34, nhanes56)
nhanes$fouryearwt <- nhanes$WTDRD1 / 2
# I added the two lines below to make graphing the
# smooth plot easier
nhanes$sodium <- nhanes$DR1TSODI / 1000
nhanes$potassium <- nhanes$DR1TPOTA / 1000

des <- svydesign(
  id = ~SDMVPSU, strat = ~SDMVSTRA, weights = ~fouryearwt,
  nest = TRUE, data = subset(nhanes, !is.na(WTDRD1))
)

des <- update(des, sodium = DR1TSODI / 1000, potassium = DR1TPOTA / 1000)
des
```

Lumley uses the following plot --- examining systolic blood pressure as a 
function of daily sodium intake --- to motivate the need to adjust for 
confounders. As we can see below in the reproduced Figure 5.10, there doesn't
appear to be much a relationship between sodium intake and average blood 
pressure. Lumley argues that we observe this simpler relationship because of 
the association between sodium and blood pressure is confounded by age.

```{r svysmoothplot}
plot(BPXSAR ~ sodium, data = nhanes, type = "n")
points(svyplot(BPXSAR ~ sodium,
  design = des, style = "transparent", xlab =
    "Dietary Sodium (g/day)", ylab = "Systolic Blood Pressure (mm Hg)"
))
lines((svysmooth(BPXSAR ~ sodium, des)))
```
To test this hypothesis, Lumley first visualizes the three variables using the
conditional plot demonstrated previously.


```{r nacl_coplot}
svycoplot(BPXSAR ~ sodium | equal.count(RIDAGEYR), des,
  style = "hexbin",
  xlab = "Dietary Sodium (g/day)",
  ylab = "Systolic BP (mmHg)",
  strip = strip.custom(var.name = "Age")
)
```

In the above plot we see a greater indication that as dietary sodium increases
, so too does systolic blood pressure. 

To more formally test the hypothesis, Lumley fits several models with
these variables included. The first two just include (1) sodium and potassium
and (2) sodium, potassium and Age.


```{r nacl_model0}
model0 <- svyglm(BPXSAR ~ sodium + potassium, design = des)
summary(model0)
```

```{r nacl_model1}
model1 <- svyglm(BPXSAR ~ sodium + potassium + RIDAGEYR, design = des)
summary(model1)
```

As we can see, the sodium and potassium coefficient signs in the first
model switch direction once age is included in the second model, demonstrating
that the two variables are associated with both age and systolic blood pressure.
The second model makes more sense intuitively, because we expect systolic 
blood pressure to increase, on average, as a function of sodium intake.

Lumley adds a few more possible confounders to `model2` and then tests 
to see whether the effects of daily dietary sodium and potassium on systolic 
blood pressure are significantly different than zero using the `regTermTest()` 
function. 

```{r nacl_model2}
model2 <- svyglm(BPXSAR ~ sodium + potassium + RIDAGEYR + RIAGENDR + BMXBMI,
  design = des
)
summary(model2)
```

```{r nacl_test_models}
regTermTest(model2, ~ potassium + sodium, df = NULL)
```

The test is formally examining whether a model with these terms is more 
likely, given the data, then one without, with the null hypothesis assuming
that the extra terms are unneccessary. As we can see, the model is 
very unlikely to fit so well with the two extra terms, so there's evidence to
support the association between the terms and blood pressure.


Lumley digs into further details of why the effect is so small --- 1 gram
of sodium (2.5 grams of salt) is a lot of salt required to increase systolic
blood presssure "only" .43 mmHg. Some explanations include measurement error,
missing data, and model misspecification. Lumley examines the last of these 
by displaying the model diagnostic plots. Model misspecification can be
examined by identifying any association between the partial residuals and
the observed sodium intake. I replicate Lumley's code below.

```{r partial_residual_plot}
par(mfrow = c(1, 2))
plot(as.vector(predict(model1)), resid(model1),
  xlab = "Fitted Values", ylab = "Residuals"
)
nonmissing <- des[-model1$na.action]
plot(nonmissing$variables$sodium,
  resid(model1, "partial")[, 1],
  xlab = "Sodium",
  ylab = "Partial Residuals"
)
```


```{r nacl_termplot}
nonmissing <- des[-model1$na.action]
par(mfrow = c(1, 2))
plot(model1, panel = make.panel.svysmooth(nonmissing))
termplot(model1,
  data = model.frame(nonmissing),
  partial = TRUE, se = TRUE, smooth = make.panel.svysmooth(nonmissing)
)
```

```{r}
int1 <- svyglm(BPXSAR ~ (sodium + potassium) * I(RIDAGEYR - 40) + RIAGENDR + BMXBMI,
  design = des
)
summary(int1)
```
### Is Weighting Needed in a Regression Model ?

Lumley caps off this chapter asking whether we even need to bother with the
specialized weighting built into the `survey` package. His answer is worth
digging into:

> Since regression models use adjustment for confounders as a way of removing 
distorted associations between exposure and response, it is plausible that a
regression model might not need sampling weights.

A key assumption here is whether the population we're estimating is stable 
across the population(s) represented by our data set. The naive, biased 
population that our sample represents when unweighted, or the "target" 
population our sample represents when re-weighted. A follow-up question would
ask whether we could even estimate the relationship as desired, if the 
effect is heterogeneous across populations. Lumley cites [@dumouchel1983using]
for further discussion on this topic.

I have more to say here --- Thinking of this article [gelman2007struggles] ---, 
but it may not fit in these notes. For now I'll end with Lumley's two 
limitations for regression models when not using weights:

1. Some important variables used in constructing the weights may not be 
available,

2. Further, the important variables mentioned above may not be suitable for 
including in the model.

Lumley urges caution in this regard, advising that even a small amount of bias
introduced from not including the weights may make any potential increase in
precision that comes from *not* using the weights as poor trade-off.

## Questions

1. This exercise uses the WA State crime data for 2004 as the population.
The data consists of crime rates and population sizes for the police districts
(in cities/towns) and shefiffs' offices (in unincorporated areas), grouped by
county.

* Take a simple random sample of ten counties from the state and use all the 
data from the sampled counties. Estimate the total number of murders and 
burglaries in the state.

```{r wacrime_51a}
county_sample <- wa_crime_df %>%
  distinct(County) %>%
  slice_sample(n = 10) %>%
  pull(County)

wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design() %>%
  summarize(
    crime = survey_total(murder_and_crime)
  )
```

* Use the population of each county as an auxiliary variable to estimate the
totals.

```{r wacrime_51b}
ratio_estimate <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design() %>%
  svyratio(~murder_and_crime, ~Population, design = .)

predict(ratio_estimate, total = sum(wa_crime_df$Population))
```

* Use the numbers of murders and burglaries in the previous year as auxiliary 
variables in a regression estimate of the totals (why can't we use a ratio
estimate here?)

```{r, wacrime_51c}
wa_crime_03_df <- readxl::read_xlsx("data/WA_crime/1984-2011.xlsx", skip = 4) %>%
  filter(Year == "2003", Population > 0) %>%
  mutate(
    murder_and_crime = `Murder Total` + `Burglary Total`,
    state_pop = sum(Population),
    County = stringr::str_to_lower(County),
    num_counties = n_distinct(County),
  ) %>%
  group_by(County) %>%
  mutate(num_agencies = n_distinct(Agency)) %>%
  ungroup() %>%
  select(
    County, Agency, Population, murder_and_crime,
    num_counties, num_agencies
  )

model_df <- wa_crime_03_df %>%
  mutate(year = "2003") %>%
  bind_rows(wa_crime_df %>% mutate(year = "2004")) %>%
  mutate(
    # We'll use 2004's numbers here for the fpc.
    num_counties = if_else(year == "2004", num_counties, 0),
    num_agencies = if_else(year == "2004", num_agencies, 0),
  ) %>%
  spread(year, murder_and_crime) %>%
  group_by(County, Agency) %>%
  summarize(
    num_counties = sum(num_counties),
    num_agencies = sum(num_agencies),
    `2003` = sum(replace_na(`2003`, 0)),
    `2004` = sum(replace_na(`2004`, 0))
  ) %>%
  ungroup() %>%
  filter(
    # Agencies were removed between 2003 and 2004.
    num_counties > 0, num_agencies > 0,
    County %in% county_sample
  )

model_design <- model_df %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  )

fit <- svyglm(`2004` ~ `2003`, design = model_design)

total_matrix <- c(sum(wa_crime_03_df$murder_and_crime))
total_matrix <- as.data.frame(total_matrix)
names(total_matrix) <- "2003"

predict(fit, newdata = total_matrix)
```

We can't use a ratio estimator here because we're not using the total population
of the year in question as the denominator, we're only looking at the total
number of murders and burglaries in the previous year and relating it to the
next, without measuring the total population, explicitly.

* Stratify the sampling so that King County is sampled with 100% probability 
 together with a simple random sample of five other counties. use population
 as an auxiliary variable to construct a common ratio estimate and a separate
 ratio estimate of the population totals.

```{r wacrime_51d}
smaller_county_sample <- wa_crime_df %>%
  distinct(County) %>%
  filter(County != "king") %>%
  slice_sample(n = 5) %>%
  pull(County)

county_list <- unique(wa_crime_df$County)

design <- wa_crime_df %>%
  filter(County == "king" | County %in% smaller_county_sample) %>%
  mutate(
    strata_label = if_else(County == "king", "King County", "WA Counties"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1)
  ) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  )

strata_totals <- wa_crime_df %>%
  mutate(strata = if_else(County == "king", "King", "WA Counties")) %>%
  group_by(strata) %>%
  summarize(Population = sum(Population)) %>%
  spread(strata, Population) %>%
  as.matrix()

separate_estimator <- svyratio(~murder_and_crime, ~Population, design,
  separate = TRUE
)
common_estimator <- svyratio(~murder_and_crime, ~Population, design)
predict(separate_estimator, total = strata_totals)
```


```{r wacrime51d_}
predict(common_estimator, total = sum(wa_crime_df$Population))
```
 
* Take simple random samples of five police districts from King County and 
five counties from the rest of the state. use population as an auxiliary
variable to construct a common ratio estimate and a separate ratio estimate of 
the population totals.

```{r wacrime_51e}
king_districts <- wa_crime_df %>%
  filter(County == "king") %>%
  pull(Agency)
sampled_king_districts <- sample(king_districts, 5)
sampled_counties <- sample(county_list, 5)

design <- wa_crime_df %>%
  filter(County %in% sampled_counties | Agency %in% sampled_king_districts) %>%
  mutate(
    strata_label = if_else(County == "king", "King County", "WA Counties"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1),
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  )


separate_estimator <- svyratio(~murder_and_crime, ~Population, design,
  separate = TRUE
)
common_estimator <- svyratio(~murder_and_crime, ~Population, design)
predict(separate_estimator, total = strata_totals)
```


```{r wacrime_51e_}
predict(common_estimator, total = sum(wa_crime_df$Population))
```

2. Using the WA state crime data as a population, take a stratified sample
of five police districts from King County and five counties from the rest of the
state. Estimate the ratio of violent crimes to non-violent crimes. Compare to
the population value.

```{r wacrime_52}
sampled_king_districts <- sample(king_districts, 5)
sampled_counties <- sample(county_list, 5)

wa_crime_df %>%
  filter(County %in% sampled_counties | Agency %in% sampled_king_districts) %>%
  mutate(
    strata_label = if_else(County == "king", "King County", "WA Counties"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1),
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  ) %>%
  summarize(
    violent_non_violent = survey_ratio(violent_crime, property_crime)
  )
```

```{r wacrime_52_check}
round(sum(wa_crime_df$violent_crime) / sum(wa_crime_df$property_crime), 2)
```

We can see that the estimate is quite close to the population value

3. Using the data from Wave 1 of the 1996 SIPP panel (see Figure 3.8)

* Estimate the ratio of population totals for monthly rent (`tmthrnt`) and
total household income (`thtrninc`) over the whole population and over the
subpopulation who pay rent.

I think Lumley may have an error here when he says that `thtrninc` is the 
total household monthly income - earlier we used `thtotinc` for this measure 
as he had increating Figure 3.9. Consequently, I use `thtotinc` below.

```{r 53a_1}
sipp_hh_sub %>%
  # Total population
  summarize(
    ratio_of_monthly_rent_to_household_income = survey_ratio(tmthrnt, thtotinc)
  )
```

```{r 53a_2}
sipp_hh_sub %>%
  filter(tmthrnt > 0) %>%
  # Rent paying subpopulation
  summarize(
    ratio_of_monthly_rent_to_household_income = survey_ratio(tmthrnt, thtotinc)
  )
```
* Compute the individual-level ratio, i.e., the proportion of household income
paid in rent, and estimate the population mean over the whole population and 
over the subpopulation who pay rent.

```{r 53b_1}
# Full Population
sipp_hh_sub %>%
  mutate(
    # I also ran the numbers if we excluded those with 0 household rent
    # and the estimates are effectively the same.
    prop_income_rent = if_else(thtotinc == 0, 0, (tmthrnt / thtotinc)),
  ) %>%
  summarize(
    prop_income_rent_est = survey_mean(prop_income_rent)
  )
```

```{r 53b_2}
sipp_hh_sub %>%
  # Rent paying subpopulation
  filter(tmthrnt > 0) %>%
  mutate(
    # I also ran the numbers if we excluded those with 0 household rent
    # and the estimates are effectively the same.
    prop_income_rent = if_else(thtotinc == 0, 0, (tmthrnt / thtotinc)),
  ) %>%
  summarize(
    prop_income_rent_est = survey_mean(prop_income_rent)
  )
```

What are we to make of these estimates being different? Well that's because
they're estimating two different things. As Lumley points out at the start of
the chapter, one is a ratio of two population-level quantities, the other is 
the population estimate of a ratio measured at the individual level.

4. Use the stratified sample from the Academic Performance Index population
to examine whether the proportion of teachers with only emergency qualifications
(`emer`) affects academic performance (as measured by 2000 API).


* What confounding variables measuring socioeconomic status of students should be 
included in the model?

Going off the web 
[documentation](https://r-survey.r-forge.r-project.org/survey/html/api.html)
of the `api` dataset from the `survey` package, it looks like there are a 
number of possible confounding variables should be included in the model. 
Here is a list with a brief explanation:
  * `meals`: The % of students eligible for subsidized meals. This is a proxy
  for poverty and is likely correlated with the academic achievement measured
  by the test.
  
  * `hsg`: percent of parents who are high school graduates. Parental academic
  achievement is likely associated with their students' academic achievement.
  
  * `avg.ed`: Average parental education level - this might be able to combine
  the above variable along with those who have college or post-graduate 
  education.
  
  * `comp.imp`  refers to a school "growth" improvement targets that may be
  related to students' academic performance.
  
  * `acs.k3` average class size years K-3 - class size is often associated with
  academic performance There is a similar `acs.46` variable for grades 4-6.
  
  *  `ell` The percent of english language learners. Since most classes are 
  typically instructed in english, a non-native english speakers may struggle
  more with academic instruction.
  
  * `full` percent fully qualified teachers. A fully qualified teacher will
  presumably be more capable of teaching than one that's not fully qualified.
  
  * `enroll` Enrollment may also be associated with the API, if larger schools
  have access to greater resources, or inversely, worse teacher to student
  ratios.

* Should 1999 API be in the model (and why, or why not?)

  *  The value of including the 1999 API score would be that its very likely one
  of the most correlated variables with the 2000 score. The downside is that it
  is also likely correlated with all the other measures, including the `emer`
  measure, and may mask that variable's weaker impact. I'll leave it out in
  my estimate to try to avoid this problem.

* Do any of the confounding variables need to be transformed?

  * Several of the binary / categorical variables will need to be transformed 
  into 0 / 1 or cell means encoding. It could also be beneficial to
  center several of the continuous variables at the mean to offer an easier
  interpretation of the model.

* Does `emer` need to be transformed?

It doesn't look like it needs to be to me. I include two plots below that
visualize the `emer` distribution (in the target population) as well as its 
relationship with the `api00` measure. While there is a right skew in the
distribution, this doesn't strike me as problematic and I think a log 
transformation - an attempt to fix the skew - would not be helpful both because
of the difficulty in handling 0 values as well as the log-scale interpretation.

It could be worth centering the `emer` value by the estimated population mean 
to make the interpretation of the intercept more valueable but I don't think
that's necessary for an adequate model interpretation here.

```{r 54_emer_eda1}
svyhist(~emer, strat_design)
```

```{r 54_emer_eda}
svyplot(api00 ~ emer, strat_design,
  main = "CA 2000 API Scores vs. Teacher Emergency Training Preparedness",
  xlab = "Teachers with emergency training",
  ylab = "API 2000"
)
```

* What is the conclusion at the end?

```{r 54}
fit <- svyglm(
  api00 ~ emer + meals + hsg + avg.ed + comp.imp +
    acs.k3 + acs.46 + ell + full + enroll,
  design = strat_design
)
summary(fit)
```

From the output above, we see that the `emer` value isn't found to be 
significantly associated (at $\alpha = 0.05$) with the 2000 API measure after
adjusting for other variables. Indeed, `meals`, `avg.ed` and `acs.46` are the
only values for which there is evidence to support a relationship at this
level. 

5. Following on from the previous exercise, fit the same model to the whole
population (the data set `apipop`) using the `glm()` function.

```{r 55}
fit_pop <- glm(api00 ~ emer + meals + hsg + avg.ed + comp.imp +
  acs.k3 + acs.46 + ell + full + enroll, data = apipop)
summary(fit_pop)
```

* Do the sample estimates agree with the population data? Do your decisions
about transforming variables hold up in the population data?

*Some* of the sample estimates agree with the population data. It is very clear
that there is a whole lot more power to detect associations when the entire 
population is present. In brief, we see that the three variables for which
an association was detected previously --- `meals`, `acs.46` and `avg.edu` ---
all have similar (within the sample based estimate margin of error) estimates
on the full population data. Additionally, many other variables now 
have significant associations that did not previously. Notably the `emer` 
variable has a positive association with the `api00` such that we'd expect to
see a .5 gain in API score for every additional percent gain in teachers that
are emergency qualified.

* Fit the same model to 100 stratified samples from the population. Is the 
sampling distribution of the coefficients close to a Normal distribution?


```{r 55_c}
OneSimulation <- function() {
  coefs <- apipop %>%
    group_by(stype) %>%
    slice_sample(n = 66) %>%
    ungroup() %>%
    as_survey_design(
      strata = stype
    ) %>%
    svyglm(api00 ~ emer + meals + hsg + avg.ed + comp.imp +
      acs.k3 + acs.46 + ell + full + enroll, design = .) %>%
    coef(.)
  return(coefs)
}
coef_dist <- replicate(100, OneSimulation())
par(mfrow = c(1, 2))
hist(coef_dist[1, ], main = "Histogram of Intercept")
hist(coef_dist[2, ], main = "Histogram of emer")
```

Yes, as we'd expect the sampling distributions are roughly normal.


6. Using the blood pressure data from NHANES 2003 - 2006, investigate the 
effect of obesity on blood pressure using the Body Mass Index and blood pressure
data.

* What variables in the data set are potential confounders?

Given the discussion in the book's example, sodium and potassium intake are 
likely confounders alongside the usual, age, sex race and socioeconomic status.
That said, i don't know if the last of these two are available given that the
variable names in the dataset are not particularly descriptive.

* Are there important confounders that are not measured?

See above - race and socioeconomic status stand out as two confounding variables
that don't appear to be measured in this dataset.

* Fit one or more suitable regression models and summarize the output.

I'll fit the same model as `model2` in the text since Lumley explains what the 
variables are in that model.

```{r 56}
fit <- svyglm(BPXSAR ~ sodium + potassium + RIDAGEYR + RIAGENDR + BMXBMI,
  design = des
)
summary(fit)
```

According to this model there is a .38 mm Hg expected increase in systolic
blood pressure for every one unit increase in BMI after adjusting for age, sex,
and daily sodium and potassium intake. In other words we'd expect a higher blood
pressure amongst those with higher BMIs. 

* Examine whether there is an interaction with age or sex.

```{r 56_interaction}
fit <- svyglm(BPXSAR ~ (RIDAGEYR + RIAGENDR) * I(BMXBMI - 25) + sodium + potassium,
  design = des
)
summary(fit)
```
I center the BMI variable at 25 (roughly the marginal average) and fit the 
model with the age and sex interactions with the centered BMI. The model fit 
shows that there's a significant negative association with the BMI-age 
interaction and no association with the gender/sex - age interaction. This 
corresponds to a amplifying effect of age --- the older you are the lower your 
blood pressure is, on average, a higher BMI will then also lead to a lower 
expected blood pressure in addition to this affect.

7. Prove that an unweighted regression estimator is approximately unbiased when
the weights depend only on variables in the model. Specifically, if the true
population regression coefficients $\beta^*$ satisfy:

$$
\sum_{i=1}^{N} x_i(y_i - x_i\beta^*) = 0
$$

and $R_i$ indicates that observation $i$ is in the sample prove that

$$
E \left [ \sum_{i=1}^{N} R_ix_i (y_i - x_i \beta^*)\right ] = 0
$$

so that the unweighted sample estimating equations are unbiased.

TODO(apeterson91)

5.8 A rough approximation to the loss of efficiency from unnecessarily using
weights can be constructed by considering the variance of the residuals in 
weighted and unweighted estimation. Assume as an approximation that the 
residuals $r_i$ are independent of the sampling weights $w_i$

* Show that 
$$ 
V[\sum_{i=1}^{n} w_ir_i] = E[w^2] V[r] + V[w]E[r^2]
$$

TODO(apeterson91)

* Now assume that the mean of the residuals is zero, and show that the 
relative efficiency of the unweighted estimate is $1 + cv(w)$ where $cv$ is the
coefficient of variation, the ratio of the standard deviation to the mean.

TODO(apeterson91)

# Chapter 6: Categorical Data Regression

Chapter 6 covers regression models for discrete outcome data --- binary or 
categorical data. The `survey` package also handles poisson and
binomial regression though neither of these are covered in this chapter.


## Logistic Regression

Lumley gives a brief overview of logistic regression which is roughly equivalent
to what can be found on 
[wikipedia](https://en.wikipedia.org/wiki/Logistic_regression), so I won't
reiterate his points here. The main take home is that while the interpretation
of the coefficients change from a linear association to an odds ratio 
association the only change to `svyglm()` is adding the 
`family = quasibinomial()` option.


### Example: Internet use in Scotland

To demonstrate how to analyze binary data, Lumley uses the Scottish Household
Survey data, examining internet use amongst the nation's populace.

```{r 6_scotland_example_eda, fig.height=8, fig.width=12}
load("Data/SHS/shs.rda") # Lumley's website data
par(mfrow = c(2, 1))
bys <- svyby(~intuse, ~ age + sex, design = shs, svymean)
plot(
  svysmooth(intuse ~ age,
    design = subset(shs, sex == "male" & !is.na(age)),
    bandwidth = 5
  ),
  ylim = c(0, 0.8), ylab = "% Using Internet",
  xlab = "Age"
)
lines(svysmooth(intuse ~ age,
  design = subset(shs, sex == "female" & !is.na(age)),
  bandwidth = 5
), lwd = 2, lty = 3)
points(bys$age, bys$intuse, pch = ifelse(bys$sex == "male", 19, 1))
legend("topright",
  pch = c(19, 1), lty = c(1, 3), lwd = c(1, 2),
  legend = c("Male", "Female"), bty = "n"
)
byinc <- svyby(~intuse, ~ sex + groupinc, design = shs, svymean)
barplot(byinc, xlab = "Income", ylab = "% Using Internet")
```

Since binary data can't be easily visualized across a continuous variable
very easily, the plots above use both smoothing and binning --- computing
the proportion point estimate within some range of age --- to understand
how internet use changes across these continuous dimensions.

We can see in the plot that internet use is lower amongst the older respondents
in the survey and men ten to use the internet more then women, except perhaps 
the very youngest. My phrasing here is intentional, to demonstrate that
the phenomenon we're observing is likely a *cohort effect* since, as Lumley 
notes, its likely that born before the arrival of the internet are less likely
to use it.

We see this same pattern in the boxplot showing internet use across income;
men using internet more than women. We also see that those with higher incomes 
tend to use the internet more than those with lower incomes. In contrast
to the cohort effect seen above, Lumley suggests that income may be more of
a real effect, and those who start earning more may be more likely to use the
internet.

Lumley then fits a series of models to quantify the relationships we're seeing 
in the plots formally. I'll summarize these briefly here and fit them below.

* Model 1 estimates the log odds of internet as a linear 
(on the log odds scale) function of age, sex and their interaction.

* Model 2 is the same as Model 1 except with two slopes for those younger and
older than age 35, respectively --- a low dimensional way to account for the 
nonlinear shape we observed previously.

* Model 3 is the same as Model 2 but adds an additional fixed effect term for 
income.

* Model 4 now adds an interaction between income and sex to account for the 
differences.
  
Lumley examines the output of all the models and for models 2 and 3 examines
what the two age-slopes for the reference group (women) is by using 
`svycontrast()`. Similarly with model 4, Lumley tests whether the 5 additional
parameters  added as the result of the income / sex interaction  lead to better
model fit. As we can see below, they do. 



```{r 6_scotland_example_models}
m <- svyglm(intuse ~ I(age - 18) * sex, design = shs, family = quasibinomial())

m2 <- svyglm(intuse ~ (pmin(age, 35) + pmax(age, 35)) * sex,
  design = shs,
  family = quasibinomial()
)
summary(m)
```


```{r 6_scotland_example_model2_output}
summary(m2)
```

```{r 6_scotland_example_model2_contrast}
svycontrast(m2, quote(`pmin(age, 35)` + `pmin(age, 35):sexfemale`))
```


```{r 6_scotland_example_model2_contrast_test}
svycontrast(m2, quote(`pmax(age, 35)` + `pmax(age, 35):sexfemale`))
```


```{r 6_scotland_example_model_3}
shs <- update(shs, income = relevel(groupinc, ref = "under 10K"))
m3 <- svyglm(intuse ~ (pmin(age, 35) + pmax(age, 35)) * sex + income,
  design = shs, family = quasibinomial()
)
summary(m3)
```


```{r 6_scotland_example_model_4}
m4 <- svyglm(intuse ~ (pmin(age, 35) + pmax(age, 35)) * sex + income * sex,
  design = shs, family = quasibinomial()
)
regTermTest(m4, ~ income:sex)
```


Double check Lumley's assertions made on linear vs. logistic regression here.

### Relative Risk Regression

Logistic regression gets its name from the "link" function that determines 
the scale on which outcome mean is modeled and estimated. For a logistic
function the link is the "logit" function, which models the log odds. Other
link functions are also possible. In particular, using the `log()` link function
models the relative risk i.e. $\log(P(Y=1)) = X\beta$. 

Lumley goes into the details of how to fit these models via `svyglm` and the
potential difficulties of estimating the relative risk between the two
distributional families. Of note, because the binomial family is more 
restrictive, estimation is more sensitive to the fitting algorithm's
parameters starting values and 

```{r relative_risk}
rr3 <- svyglm(intuse ~ (pmin(age, 35) + pmax(age, 35)) * sex + income,
  design = shs, family = quasibinomial(log),
  start = c(-0.5, rep(0, 10))
)
rr4 <- svyglm(intuse ~ (pmin(age, 35) + pmax(age, 35)) * sex + income,
  design = shs, family = quasipoisson(log)
)
summary(rr3)
```


```{r relative_risk_summary}
summary(rr4)
```

### Ordinal Regression

The logit function introduced in the first section can be extended for use
from binomial outcome data to categorical -- typically ordinal, or ordered
categorical data. Unfortunately, the data that Lumley uses for this section is
not available so I'll skip any notes on this, noting that the model 
interpretation for logit ordinal regression is the same as for a typical
iid logit ordinal model.

```{r prop_odds, eval = FALSE}
## Data isn't available on lumley's website - or at least the data that is
# there associated with "nhanes3" does not contain the variables below.
dhanes <- svydesign(
  id = ~SDPPSU6, strat = ~SDPSTRA6,
  weight = ~WTPFHX6,
  ## nest = TRUE indicates the PSU identifier is nested
  ## within stratum - repeated across strata
  nest = TRUE,
  data = subset(nhanes3, !is.na(WTPFHX6))
)
dhanes <- update(dhanes, fpg = ifelse(phpfast >= 8 & gip < 8E3, gip, NA))
dhanes <- update(dhanes,
  diab = cut(fpg, c(0, 110, 125, Inf)),
  diabi = cut(fpg, c(0, 100, 125, Inf))
)
dhanes <- update(dhanes,
  cadmium = ifelse(upd < 88880, udp, NA),
  creatinine = ifelse(urp < 88880, urp, NA)
)
dhanes <- update(dhanes,
  age = ifelse(hsaitmor > 1000, NA, hsaitmor / 12)
)

model0 <- svyolr(diab ~ cadmium + creatine, design = dhanes)
```

### Other cumulative Link models

In this subsection Lumley discusses the log-log link function. The log log,
probit, and `cauchit` or inverse Cauchy link function are all supported by the
`svyolr` function  and are collectively referred to as `cumulative link models`.

## Loglinear Models

Lumley introduces log linear models in the context of the chi-square tests 
(via `svychisq()`) introduced previously testing association between count 
variables. These functions test a similar hypothesis using different methods and
I'd suggest looking at the function documentation closely to determine if
choosing between the two would matter in a particular circumstance.

```{r loglinear_demo}
droplevels <- function(f) as.factor(as.character(f))
chis <- update(chis, smoking = droplevels(smoking), ins = droplevels(ins))
null <- svyloglin(~ smoking + ins, chis)
# Dot below includes all previous variables
saturated <- update(null, ~ . + smoking:ins)
anova(null, saturated)
```

The anova output above shows two p-values  according to two test statistics, 
one the deviance and the other the score. Again, the difference here is quite
"in the weeds" of how test statistic distributions are computed so I'd suggest
consulting a general reference on generalized linear models like 
[@dobson2018introduction] and/or the function documentation.

```{r loglinear_demo_part2}
svychisq(~ smoking + ins, chis)
```

```{r loglinear_demo_part3}
pf(130.1143, 1.992, 157.338, lower.tail = FALSE)
```

```{r loglinear_demo_part4}
svychisq(~ smoking + ins, chis, statistic = "Chisq")
```

```{r loglinear_demo_part5}
summary(null)
```

```{r loglinear_demo_part6}
summary(saturated)
```

```{r loglinear_demo_part7}
model.matrix(saturated)
```

### Choosing Models

Lumley explores model selection beyond just statistical testing by discussing 
graphical and hierarchical loglinear models. My sense is that the discussion
here is not complete and I'd encourage any reader here to consult the 
references he points to for further reading on the topic.

**Example: neck and back pain in NHIS**

I couldn't find the data associated with Lumley's example on his website
or from a cursory Google search for NHIS data. Furthermore, I found it 
difficult to parse some of Lumley's words here. For example, for those reading 
the book, the two graphical models listed in Figure 6.11 look identical to me 
when the text states that the graphics are supposed to correspond to two 
different models.

### Linear Association Models

The log linear models can be used to test linear association of ordered 
categorical variables by coding the variables with ordered numbers and then
running the loglinear tests discussed previously. Lumley demonstrates with the
Scottish Household Survey data.

Lumley first starts by looking at internet use, now an ordinal categorical 
variable, `rc5` across income levels as before. Again, the similarity to
the chi-square model is obvious, as we're looking at models with fixed effects
only --- a "null" model --- and comparing it to a "saturated" model --- one with
interaction effects. The `anova()` call below, tests whether the additional
parameters estimated by the interaction model provide a greater model fit than
the model with the fixed effects alone. The idea being that if it does,
then there's evidence to support the hypothesis that internet use varies across
income levels, and since we're measuring internet use on an ordinal scale we
have evidence that more income corresponds to more internet use. Note that
below, only the models fit with the `as.numeric()` pieces are testing linear
association on the ordinal scale, while the others are a simple categorical
test.

```{r loglinear_association_shs_part1}
shs <- update(shs, income = ifelse(groupinc == "missing", NA, groupinc))
null <- svyloglin(~ rc5 + income, shs)
saturated <- update(null, ~ .^2)
anova(null, saturated)
```

For the first model fit, we have a low p-value, so we reject the null model 
which make sense substantively. We've already seen that income is associated
with internet use in the previous analysis.


```{r loglinear_association_shs_part2}
lin <- update(null, ~ . + as.numeric(rc5):as.numeric(income))
anova(null, lin)
```
Now the model is updated with the ordinal categorical variable of internet
use and income, again we have a significant result.


```{r loglinear_association_shs_part3}
anova(lin, saturated)
```
Now we compare the ordinal model to the categorical, non-ordered model. 
It would make sense that the ordinal model provides a better fit than the 
categorical, and although that's what we see in the book it isn't what we
see when I run the code, even with the same Deviance and Score test 
statistics... I suspect this is a bug. The survey R package isn't hosted on
github but I'll try to raise an issue with Lumley via email.


```{r loglinear_association_shs_part4}
shs <- update(shs, agegp = cut(age, c(20, 40, 60, 100)))
null <- svyloglin(~ agegp + rc5, shs)
sat <- update(null, ~ .^2)
lin <- update(null, ~ . + as.numeric(rc5):as.numeric(agegp))
anova(null, lin)
```

Now we look at the association of internet use with age tested via the 
log linear models. Again, we find that the ordinal interaction model has 
a better fit to the data according to the Deviance and Score tests.


```{r loglinear_association_shs_part5}
anova(lin, sat)
```

Looking at the ordinal vs. categorical model comparison we again see a 
discrepancy between my results and Lumleys, with mine suggesting that the
ordinal model does not provide a better fit than the categorical model...


```{r loglinear_association_shs_par6}
# code for producing Table 6.1
null <- svyloglin(~ agegp + income + rc5, shs)
m1 <- update(null, ~ . + as.numeric(agegp):as.numeric(rc5))
m2 <- update(m1, ~ . + agegp:income)
m3 <- update(m2, ~ . + as.numeric(income):as.numeric(rc5))
m4 <- update(m2, ~ . + income:rc5)
full <- update(null, ~ .^2)
```

As a final step in this demonstration, Lumley then looks at each possible
model that has both interactions, noting that an interaction between age
group and income isn't possible because of sparsity of data amongst some
income / age group categories.

Looking at Table 6.1 in the book, Lumley examines the ratio of deviance to 
degrees of freedom to provide a heuristic of determining whether the full
model fits well. I'm not fully convinced of his discussion here and there,
again, appears to be an error in his table.

## Questions

1. Using the same data as in Section 5.2.4, define hypertension as systolic 
blood pressure greater than 140 mm Hg or diastolic blood pressure greater than
90 mmHg. Fit logistic regression models to investigate the association between
dietary sodium and potassium and hypertension.

```{r q6_1}
des <- svydesign(
  id = ~SDMVPSU, strat = ~SDMVSTRA, weights = ~fouryearwt,
  nest = TRUE, data = subset(nhanes, !is.na(WTDRD1))
)

des <- update(des,
  sodium = DR1TSODI / 1000, potassium = DR1TPOTA / 1000,
  hypertension = (BPXSAR > 140 | BPXDAR > 90) * 1
)
summary(svyglm(hypertension ~ sodium + potassium, design = des))
```

We see sodium intake is negatively associated with hypertension while
potassium is positively associated. Because we're not adjusting for age like we
saw previously, the sodium intake coefficient is biased up from its adjusted
rate.

2. This exercise uses the WA State Crime data for 2004 as the population. The
data consists of crime rates and population size for the police districts 
in cities/towns and sheriffs' offices in unincorporated areas, grouped by 
county.

 * Take a simple random sample of 10 counties from the state and use all the 
 data from the sampled counties. Estimate the total number of murders and 
 burglaries in the state.
 
```{r q6_2a}
county_sample <- wa_crime_df %>%
  distinct(County) %>%
  slice_sample(n = 10) %>%
  pull(County)

wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  ) %>%
  summarize(total = survey_total(murder_and_crime)) %>%
  mutate(Q = "a")
```
 
 * Fit a poisson regression (`family=quasipoisson`) to model the relationship
 between number of murders and population. Poisson regression fits a linear
 model to the logarithm of the mean of the outcome variable. If the murder rate
 were constant, the optimal transformation of the predictor variable would be 
 the logarithm of population, and its coefficient would be 1.0. Is this 
 supported by the data?
 
```{r q6_2b}
srs_design <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  )

poisson_fit <- svyglm(murder ~ I(log(Population)),
  family = quasipoisson,
  design = srs_design
)
summary(poisson_fit)
```

Yes. We see that the estimate is 1.13 which is roughly 1 and within the 
standard error. Furthermore, the t-test shows that there is evidence this 
estimate is not 0 at $\alpha = 0.05$.
 
 * Predict the total number of murders in the state using the Poisson 
 regression model. Compare to a ratio estimator using population as the 
 auxiliary variable.
 
```{r q6_2c}
true_murder_count <- sum(wa_crime_df$murder)
total_population <- sum(wa_crime_df$Population)
# doesn't work
# predict(poisson_fit, newdata = wa_crime_df, type = "response",
#        total = sum(wa_crime_df$Population))
# Works - for mean estimate, care needed for summing variance
sum(predict(poisson_fit, newdata = wa_crime_df, type = "response"))
```


```{r q6_2c_ratio_estimator}
predict(
  svyratio(~murder, ~Population,
    design = srs_design
  ),
  total = sum(wa_crime_df$Population)
)
```


We see that while both estimates are reasonably close to the true state 2004 
murder count of `r true_murder_count`, the ratio estimator offers a readily 
available standard error while its not clear how to extract the same estimate
from the `svyglm` output. Note that the same code arguments used extract totals
in Lumley's election example does not appear to work here...


 * Take simple random samples of five police districts from King County and five
 counties from the rest of the state. Fit a Poisson regression model with 
 population and stratum (King County vs elsewhere) as predictors. Predict the
 total number of murders in the state.
 
```{r q6_2d}
agency_sample <- wa_crime_df %>%
  filter(County == "king") %>%
  distinct(Agency) %>%
  slice_sample(n = 10) %>%
  pull(Agency)

non_king_county_sample <- wa_crime_df %>%
  filter(County != "king") %>%
  distinct(County) %>%
  slice_sample(n = 10) %>%
  pull(County)

county_list <- unique(wa_crime_df$County)

strata_design <- wa_crime_df %>%
  filter(County %in% non_king_county_sample | Agency %in% agency_sample) %>%
  mutate(
    strata_label = if_else(County == "king", "strata 1", "strata 2"),
    num_counties = if_else(County == "king", 1, length(county_list) - 1)
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  )


poisson_fit <- svyglm(murder ~ I(log(Population)) + strata_label,
  design = strata_design,
  family = quasipoisson
)
# doesn't produce appropriate output
# predict(poisson_fit, total = total_population)
sum(predict(poisson_fit,
  newdata = wa_crime_df %>% mutate(strata_label = if_else(County == "king", "strata 1", "strata 2")),
  type = "response"
))
```
This estimate appears to again, make sense though we have no standard error
estimate readily available to compare with the previous. One would guess that
it would be more precise, given extra information that comes from including
the King County agencies.
 
3. The variable MISEFFRT asks "How often in the past 30 days did you feel that 
everything was an effort?", on a 1-5 scale with 1 meaning "All" and 5 meaning 
"none". Investigate whether this variable varies seasonally and whether it 
peaks in winter by defining predictor variables cos(IMONTH * 0.5236) and 
sin(IMONTH * 0.5236), which describe smooth anual cycles and fitting:

 * A logistic regression model with outcome `MISEFFRT = 5`
 * A linear regresion model with outcome MISEFFRT
 * What further modeling could you do to investigate whether sunlight intensity 
   was related to this seasonal variation.
   
It isn't clear to what dataset Lumley is referring to here... so I'll leave
this question unanswered.
   
4. Using the California Health Interview Study 2005 data,

 * Fit a logistic regression model to the relationship between the probability 
 of having health insurance (`ins`) and household annual income (`ak22_p`). 
 Important potential confounders include age (`srage_p`), sex (`srsex`) and 
 race (`racecen`) and interactions may also be important.
 
```{r q6_4a}
fit <- svyglm(I((ins == 1) * 1) ~ ak22_p + srage_p + srsex,
  design = chis,
  family = quasibinomial
)
summary(fit)
```

 * What would be the impact on the interpretation of the income coefficient of
 adding a variable to the model indicating whether an employer provided
 health insurance?
 
Presumably income is correlated with employee offered healthcare insurance, 
though I don't know this for a fact. If this were the case then we'd see that
the effect of the income coefficient would be attenuated (move towards zero)
since its effect would now be more precisely captured by the employee
offered health care measurement.
 
5. Using the California Health Interview Study 2005 data, fit a relative risk
regression model to the relationship between the probability of having health
insurance (`ins`) and household annual income (`ak22_p`), age (`srage_p`),
sex (`srsex`) and race (`racecen`) . Compare the coefficients to those from a
logistic regression.

```{r q6_5a, eval = FALSE}
fit <- svyglm(I((ins == 1) * 1) ~ ak22_p,
  design = chis,
  family = quasibinomial(link = "log"),
  start = c(-.5, 0),
  control = list(maxit = 150)
)
summary(fit)
```

Despite trying several different starting values, "max iterations", and model
specifications, I wasn't able to fit a model as specified without getting
warning messages or errors. In general if the model *can* be fit, the 
exponentiated intercept represents the adjusted probability of the event
occuring --- in this case having health insurance --- and each subsequent
exponentiated coefficient represents the increase in probability, or relative
risk of the event occuring, conditional on a one unit change in value of the
covariate.

6. Using the same data as in Section 5.2.4, create an ordinal blood pressure
variable based on systolic and diastolic pressure with categories "normal" 
(systolic < 120 and diastolic < 80), "prehypertension" (systolic < 140,
diastolic < 90), "hypertension stage 1" (systolic < 160, diastolic < 100),
and "hypertension stage 2" ( systolic at least 160 or diastolic at least 100). 
Fit proportional odds regression models to investigate the association between 
dietary sodium and potassium and hypertension.

```{r q6_6}
nhanes <- nhanes %>%
  mutate(
    ordinal_high_bp = factor(dplyr::case_when(
      BPXSAR < 120 & BPXDAR < 80 ~ "Normal",
      (BPXSAR < 140 & BPXSAR >= 120) & (BPXDAR >= 80 & BPXDAR < 90) ~
        "PreHypertension",
      (BPXSAR >= 140 & BPXSAR < 160) & (BPXDAR >= 90 & BPXDAR < 100) ~
        "Hypertension Stage 1",
      BPXSAR >= 160 & BPXDAR >= 100 ~ "Hypertension Stage 1"
    ), levels = c(
      "Normal", "PreHypertension", "Hypertension Stage 1",
      "Hypertension Stage 2"
    ))
  )

des <- svydesign(
  id = ~SDMVPSU, strat = ~SDMVSTRA, weights = ~fouryearwt,
  nest = TRUE, data = subset(nhanes, !is.na(WTDRD1))
)

fit <- svyolr(ordinal_high_bp ~ sodium + potassium, design = des)
summary(fit)
```

Because many of the individuals have blood pressure values that aren't covered
by the categories Lumley listed, we lose ~9000 observations leading to 
a decrease in the precision of our estimates. Notably, the sodium coefficient
is no now significant (|t-value| < 2). Because the missignness here is 
self-caused I wouldn't draw any strong conclusions from this model.

7. Using data for Florida (`X_STATE = 12`) from the 2007 BRFSS, fit a loglinear
model to associations between the following risk factors and behaviors:
perform vigorous physical activity (`VIGPACT`), eat five or more servings of
fruit or vegetables per day (`X_FV5SRV`), binge drinking of alcohol 
(`X_RFBING4`), ever had an HIV test (`HIVST5`), ever had Hepatitis B vaccine 
(`HEPBVAC`), age group (`X_AGE_G`) and sex, `X_SEXG`. All except age group are
binary. You will need to remove missing values, coded 7,8 or 9.

```{r q6_7, eval = FALSE}
brfss_sub <- subset(brfss, X_STATE == 12 & !any(VIGPACT %in% c(7, 8, 9)) &
  !any(X_FV5SRV %in% 7:9) & !any(X_RFBING4 %in% 7:9) &
  !any(HIVTST5 %in% 7:9) & !any(HEPBVAC %in% 7:9) &
  !any(X_AGE_G %in% 7:9) & !any(X_SEXG_ %in% 7:9))
loglin_fit <- svyloglin(~ VIGPACT + X_FV5SRV + X_RFBING4 + HIVTST5 + HEPBVAC +
  X_AGE_G + X_SEXG_, design = brfss_sub)
summary(loglin_fit)
```

Despite all the subsetting I received the following error message when trying
to fit the model as suggested. I'm guessing the dimensionality of the 
model matrix is quite large and the underlying functions don't use a sparse
representation...

`Error: vector memory limit of 50.0 Gb reached, see mem.maxVSize()`

# Chapter 7: Post-Stratification, Raking, and Calibration

## Introduction - Motivation

Lumley motivates the need to explore the three titular topics by expanding on
the principle developed in the second chapter --- stratification. Similar as to
how making use of the extra information available in strata we can improve
estimates in straightforward estimation of totals and means, Lumley's focus in
this chapter is how to use the "auxiliary" information to adjust for
non-response bias and improve the precision of the estimates.

## Post-Stratification

Post-stratification is exactly what it sounds like - re-weighting estimates
according to strata totals *after* or apart from any initial strata that might
have been involved in the inital sampling design.

Consider a relatively straightforward design in which there's a population of
subjects of size $N$ that can be partitioned into $K$ mutually exclusive strata
from which any of the $N_k$ individuals in that strata can be sampled for $n_k$
strata samples. In this setting the sampling weights for each individual in
group $k$ is $\frac{N_k}{n_k}$ and $N_k$ is known without any uncertainty.

If the sampling were not stratified but $N_k$ were still known, the group sizes
would not be exactly correct by simple Horvitz-Thompson estimation, but they
could be corrected by re-weighting so that the sizes are correct as they would
be in stratified sampling.

Specifically, take each weight $w_i = \frac{1}{\pi_i}$ and construct new weights
$w_i^* = \frac{g_i}{\pi_i} = \frac{N_k}{\hat{N}_k} \times \frac{1}{\pi_i}$.

For estimating the group side of the kth group then, we'll have

$$
n_k \times \frac{g_i}{\pi_i} = n_k \times \frac{1}{\pi_i} \times
\frac{N_k}{\hat{N}_k} = n_k \times \frac{\hat{N}_k}{n_k} \times 
\frac{N_k}{\hat{N}_k} = N_k,
$$ where $\pi_i = \frac{n_k}{\hat{N}_k}$. The consequence of this re-weighting
means that the estimated sub group population is exactly correct and subsequent
estimates within or across these groups benefit from the extra information.

Of course, as Lumley notes, there's a problem if no entities were sampled in the
particular strata of interest - you can't re-weight the number 0. Still since
this is unlikely to happen for groups and samples of "reasonable" size
post-stratification is still a worthy strategy given the potential reductions in
variance that are possible.

### Illustration

Lumley's illustration of post-stratification looks at the two-stage sample drawn
from the API population, with 40 school districts sampled from California and
then up to 5 schools sampled from each district. Lumley uses this example to
illustrate how improvements to precision can be made via post-stratification --
or not.

We'll start with a reminder of the sample design used here: a two-stage sample.

```{r post_stratify}
clus2_design
```

Then information about the population group sizes is included in the call to
`postStratify()` as well as the variable/strata across which to post-stratify.

```{r ps_design_obj}
pop.types <- data.frame(stype = c("E", "H", "M"), Freq = c(4421, 755, 1018))
ps_design <- postStratify(clus2_design, strata = ~stype, population = pop.types)
ps_design
```

Totals, and so on are then estimated in the usual fashion. In this example
there's a large difference in the variability of the estimated total when
comparing the naive and post-stratified estimates because much of the
variability in the number of students enrolled can be explained by the school
type - elementary schools are typically smaller than middle schools and
highschools. By including more information about the types of schools in the
overall population, the standard error is decreased by a factor of \~ 2.6.

```{r ps_compare_2stage_enroll}
svytotal(~enroll, clus2_design, na.rm = TRUE)
```

```{r ps_compare_ps_enroll}
svytotal(~enroll, ps_design, na.rm = TRUE)
```

In contrast, school type is not associated with the variability in the school
scores measured by the Academic Performance Index - denoted below by `api00`.

```{r ps_compare_2stage_api}
svymean(~api00, clus2_design)
```

```{r ps_compare_ps_api}
svymean(~api00, ps_design)
```

Indeed, the score is specifically setup to be standardized across school types
and as such there's little variance reduction observed by using the
post-stratification information in this instance.

Lumley notes that if the api dataset were a real survey, non response might vary
as a function of school type and in which case post-stratification could help
reduce non-response bias.

## Raking

If one were to post-stratify using more than one variable would require the
complete joint distribution of both variables. This can be problematic 
because the population totals for the joint distribution - or cross 
classification as Lumley calls it - is not available. Raking is a method
that aims to overcome this problem.

> The process involves post-stratifying on each set of variables in turn, and 
repeating this process until the weights stop changing.

Lumley further highlights the connection between log-linear regression models
and raking:

> Raking could be considered a form of post-stratification where a log-linear 
model is used to smooth out the sample and population tables before the weights
are adjusted.


```{r}
load("Data/Family Resource Survey/frs.rda")
frs.des <- svydesign(ids = ~PSU, data = frs)
pop.ctband <- data.frame(
  CTBAND = 1:9,
  Freq = c(
    515672, 547548, 351599, 291425,
    266257, 147851, 87767, 9190, 19670
  )
)
pop.tenure <- data.frame(
  TENURE = 1:4,
  Freq = c(1459205, 493237, 128189, 156348)
)

frs.raked <- rake(frs.des,
  sample = list(~CTBAND, ~TENURE),
  population = list(pop.ctband, pop.tenure)
)
overall <- svymean(~HHINC, frs.raked)
with_children <- svymean(~HHINC, subset(frs.raked, DEPCHLDH > 0))
children_singleparent <- svymean(~HHINC, subset(frs.raked, DEPCHLDH > 0 & ADULTH == 1))
c(
  "Overall" = overall,
  "With Children" = with_children,
  "Single Parent" = children_singleparent
)
```

## Generalized Raking, Greg Estimation, and Calibration

Lumley identifies two ways to understand post-stratification:

1. Post-stratification makes small changes to the sampling weights such that the 
estimated totals match the population totals.

2. Post-stratification is a regression estimator, where each post-stratum is 
an indicator in a regression model.

An extension of the first view leads to calibration estimators while the 
second leads to generalized regression estimators. The former requires 
correctly specifying how to change the weights, the second requires correctly
specifying the model. Both can lead to great increases in precision of the
target estimates.

Lumley's motivation of calibration starts with the regression estimate of a
population total: if we have the auxiliary variable $X_i$ available on all
units in the population and an estimated $\hat{\beta}$ from a sample, we can
estimate $\hat{T}$ as the sum of the predicted values from the regression.

$$
\hat{T}_{reg} = \sum_{i=1}^N X_i\hat{\beta}
$$

From this starting point, Lumley describes that calibration follows a similar 
form, with the unknown parameter $\hat{\beta}$ know a function of the 
calibration weights $g_i$ and original sampling weights $\pi_i$ defined in such
a way that the population total of $X$ is equal to the estimated total of $X$.
Lumley identifies this as the *calibration constraints*:

$$
T_x = \sum_{i=1}^{n} \frac{g_i}{\pi_i} X_i.
$$

However, this constraint alone will not uniquely identify the $g_i$. 
Consequently, the specification of calibration weights are completed by 
requiring that they be "close" to the sampling weights - minimizing a distance
function, while still satisfying the previous constraint. 

Calibration provides a unified view of post-stratification and raking. As Lumley 
states:

> In linear regression calibration, the calibration weights $g_i$ are a linear 
function of the auxiliary variables; in raking calibration the calibration
weights are a multiplicative function of the auxiliary variables.

Variance estimation proceeds in a similar fashion for calibration as it did
for post-stratification, by constructing an unbiased estimator for the residual
between $Y_i$ and the estimated mean, or population total.

## Calibration in R

**Linear regression calibration**

We're in a similar spot as before with regard to the election data example.
```{r calibration_demo, eval = FALSE}
```


```{r calibration_raking_demo}
pop.size <- sum(pop.ctband$Freq)
pop.totals <- c(
  "(intercept)" = pop.size, pop.ctband$Freq[-1],
  pop.tenure$Freq[-1]
)
frs.cal <- calibrate(frs.des,
  formula = ~ factor(CTBAND) + factor(TENURE),
  population = pop.totals,
  calfun = "raking"
)
svymean(~HHINC, frs.cal)
svymean(~HHINC, subset(frs.cal, DEPCHLDH > 0))
svymean(~HHINC, subset(frs.cal, DEPCHLDH > 0 & ADULTH == 1))
```

#### Comparing calibration methods 

```{r calibration_comparison_setup}
clus1 <- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc)
logit_cal <- calibrate(clus1, ~ stype + api99,
  population = c(6194, 755, 1018, 3914069),
  calfun = "logit", bounds = c(0.7, 1.7)
)
svymean(~api00, clus1)
```

```{r logit_calibration}
svymean(~api00, logit_cal)
```

```{r calibration_comparison_regression}
m0 <- svyglm(api00 ~ ell + mobility + emer, clus1)
summary(svyglm(api00 ~ ell + mobility + emer, clus1))
```
```{r regression_calibration}
m1 <- svyglm(api00 ~ ell + mobility + emer, logit_cal)
summary(svyglm(api00 ~ ell + mobility + emer, logit_cal))
```

```{r calibration_prediction0}
predict(m0, newdata = data.frame(ell = 5, mobility = 10, emer = 10))
```

```{r calibration_prediction1}
predict(m1, newdata = data.frame(ell = 5, mobility = 10, emer = 10))
```

#### Cluster-level weights

Although altering the weights can lead to higher precision of estimates 
sampling weights applied to clusters - which are identical - can then lead
to unintuitive results -- Lumley gives the example of mothers and infants 
sampled together but the number of infants not adding up to the number of
mothers when using the calibrated weights. Consequently, Lumley includes an
option in the `survey` package to force within-cluster weights to be identical 
when calibrated at a given stage --- denoted below by the `aggregate.stage` 
argument.


To illustrate Lumley uses the `clus2_design` from earlier in the chapter, where
the design was post-stratified on school type. I don't really follow Lumley's
argument here but he says that the there is a loss of precision because of the
added constraints, but that's not what we see below or in the text - the 
constrained calibration has a lower standard error than the post-stratified 
design... Its hard to inspect things too carefully here because Lumley
uses a `cal` variable that's assigned a calibration object, presumably, but
does not show how he assigns it in the text, so we're left wondering.
```{r cluster_calibrated_weights}
cal2 <- calibrate(clus2_design, ~stype,
  pop = c(4421 + 755 + 1018, 755, 1018),
  aggregate.stage = 1
)
svytotal(~enroll, cal2, na.rm = TRUE)
```

```{r cluster_calibrated_weights_psdesign}
svytotal(~enroll, ps_design, na.rm = TRUE)
```

```{r calibration_weights_comparison, eval = FALSE}
range(weights(cal) / weights(clus2_design))
```

```{r calibration2_weights_comparison}
range(weights(cal2) / weights(clus2_design))
```

### Basu's Elephants

Lumley walks through a classic story[@basu2011essay] in statistics about how  
poor use of auxiliary information can lead to unreasonable behavior of design-
based inference. Lumley then goes on to show how calibrated weights could make
this more efficient. I'll summarize briefly below.

Suppose a circus owner has 50 elephants and wants to estimate their 
total weight. The catch? The owner only wants to use **one** of the elephants
to construct the estimate.

One could construct an unbiased point estimate by taking a randomly sampled
elephant's weight and multiplying it by fifty. No estimate of the variance is
available of course, because there's no way to get an estimate of the 
variability in the elephants' weights.

Alternatively, a **model** based approach could depend on some auxiliary variable.
Suppose the circus owner knew one particular elephant named Sambo was about
average weight when all the elephants were weighed some years ago. The proposed
method here then would be to sample Sambo with 100% probability and multiply his
weight by 50. Lumley notes that this can't be considered a valid **design** 
based estimate because all the other elephants had 0% probability of being
sampled.

Basu then imagines a compromise design that conforms to the necessary
conditions required for design based inference, but that produces a nonsensical
estimate. If Sambo was sampled with high probility, say 99%, then the point
estimate would be $\frac{100}{99} \times$ Sambo's weight if Sambo is sampled and
5000 $\times$ the weight of any other elephant.

Obviously, this is not a good estimate, though Lumley notes that it will
fulfill the Horvitz Thompson Property of being unbiased when averaging over
repeated sampling. The problem of course being in the extreme variability of
the estimate.

Lumley uses this scenario as an opportunity to discuss how to best use the 
auxiliary information (Sambo's roughly average weight) in the context of setting
up a design based estimator, arguing that the use of the information and the
Horvitz Thompson Estimator are inappropriately used.

#### Using auxiliary information in design

The first point Lumley expands on is how to use auxiliary information. He argues
that a stratified sample would be a better way to use information that Sambo 
is roughly average --- splitting elephants according to whether they were 
small, middle or large looking. 
[Ranked Set Sampling](https://www.asc.ohio-state.edu/dean.9/papers/wolfe-ranked-set-sampling.pdf)
is also called out as a strategy that might be more useful in this setting.

#### Using Auxiliary Information in Analysis

The bigger point Lumley wants to make is that it would've been better to use
the population size information to calibrate the weights, i.e. estimate the
population total with weights $\frac{g_i}{\pi_i} := 50$, so that
the estimate would be, as in the first approach, 50 times a sampled elephant's 
weight.

Lumley also lays out two ratio and difference calibration based models that
use the previous elephant's weight as a way to more precisely estimate the 
change in elephants weight since last weighing as as a generalization to the
total. 


All-in-all, Lumley's point is to highlight how auxiliary information can be
more efficiently utilized and to demonstrate how the simple example fails to
realize the full power of a design based approach.


### Selecting Auxiliary Variables for Non-Response

All the methods discussed thus far this chapter can be used to reduce the bias
from missing data, specifically what Lumley calls *unit non-response*. The 
phenomenon when the sampled unit cannot be measured, for example a person 
sampled for a telephone interview does not pick up the phone.

Missing data is an interesting research topic in its own right with standard
fundamentals describing the different 
[mechanisms]((https://en.wikipedia.org/wiki/Missing_data#Types) or models of 
how missing data may emerge. Lumley's discussion of how auxiliary variables
for non-response can be selected is equivalent to the missing data mechanism
known as "Missing at Random", which implies that the fact that a
measurement is missing is independent of the measurement itself, conditional
on the other variables measured.

In the design-based view, this can mean one of several things, though Lumley
focuses mainly on the strata in post-stratification. That is, the 
"other variables measured" refers to the strata information. 

Lumley uses a telephone survey to illustrate this concept. If non-response
was higher for land line than cellphone users but within each group the 
probability of responding was independent of the measure itself, then
an analysis that combined these two groups together would be biased, but a 
post-stratified analysis would not be, since it estimated the strata specific
rates.


#### Direct Standardization 

Lumley identifies "Direct Standardization" as an application of 
post-stratification to extrapolate an estimate in a different population than
the sampled population, while adjusting for as many known confounders as
possible. This is a bit like comparing regression predictions.

####  Standard error estimation

Lumley makes a brief note here that the same approach for computing standard
errors with complete data is used for incomplete data. Though, he makes 
a note that "secondary analysis" of large-scale surveys is not completely 
possible --- I'm not clear what he means here, if this is dependent on some
sampling stage specific information or perhaps he is referring to "domain" or
sub-population estimation.

In any case, Lumley states that a conservative approach is used in this case
when the calibration estimates are used --- again, I'm guessing he's referring 
to the `survey` R package's implementation, though it isn't explicit. However,
if replicate weights are available, then a full estimate is available.

## Questions

1. Using the WA State Crime population, take a stratified random sample of five
police districts from King County and five counties from the rest of the state.

Setting up the sample design similar to before...

```{r q71}
agency_sample <- wa_crime_df %>%
  filter(County == "king") %>%
  distinct(Agency) %>%
  slice_sample(n = 10) %>%
  pull(Agency)

non_king_county_sample <- wa_crime_df %>%
  filter(County != "king") %>%
  distinct(County) %>%
  slice_sample(n = 10) %>%
  pull(County)

county_list <- unique(wa_crime_df$County)

strata_design <- wa_crime_df %>%
  filter(County %in% non_king_county_sample | Agency %in% agency_sample) %>%
  mutate(
    strata_label = factor(if_else(County == "king", "strata 1", "strata 2")),
    num_counties = if_else(County == "king", 1, length(county_list) - 1)
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties, num_agencies),
    strata = strata_label
  )
```

* a. Calibrate the sample using stratum and population as the auxiliary 
variables. Estimate the number of murders and number of burglaries in the state 
using the calibrated and un-calibrated sample.

```{r q71a}
pop_size <- wa_crime_df %>%
  summarize(p = sum(Population)) %>%
  pull(p)
non_king_county_pop_size <- wa_crime_df %>%
  filter(County != "king") %>%
  summarize(p = sum(Population)) %>%
  pull(p)

pop.totals <- c(
  "(Intercept)" = pop_size,
  "strata_labelstrata 2" = non_king_county_pop_size
)
wa_crime_cal <- calibrate(strata_design,
  formula = ~strata_label,
  population = pop.totals
)
rbind(
  c("calibration", svytotal(~murder_and_crime, wa_crime_cal)),
  c("Sample-Based", svytotal(~murder_and_crime, strata_design))
)
```

The calibration numbers look *far* too high here, which is puzzling given that
the weights should be exactly calibrated to better reproduce the population
total.


* b. Convert the original survey design object to use jackknife replicate 
weights. Calibrate the replicate-weight design using the same auxiliary 
variables and estimate the number of burglaries and of murders in the state.

```{r q71b}
rep_design <- survey::as.svrepdesign(strata_design)

wa_crime_rep_cal <- calibrate(rep_design,
  formula = ~strata_label,
  population = pop.totals
)
svytotal(~murder_and_crime, wa_crime_rep_cal)
```

This produces the same, erroneous, number as before.

* c. Calibrate the sample using the population and number of burglaries in the
previous year as auxiliary variables, and estimate the number of burglaries and 
murders in the state.

```{r q71c, eval = FALSE}
wa_crime_03_df <- readxl::read_xlsx("data/WA_crime/1984-2011.xlsx",
  skip = 4
) %>%
  filter(Year == "2003", Population > 0) %>%
  mutate(
    murder_and_crime = `Murder Total` + `Burglary Total`,
    violent_crime = `Violent Crime Total`,
    burglaries = `Burglary Total`,
    property_crime = `Property Crime Total`,
    state_pop = sum(Population),
    County = stringr::str_to_lower(County),
    num_counties = n_distinct(County),
  ) %>%
  group_by(County) %>%
  mutate(num_agencies = n_distinct(Agency)) %>%
  ungroup() %>%
  select(
    County, Agency, Population, murder_and_crime, burglaries, property_crime,
    violent_crime, num_counties, num_agencies
  )

cols_to_keep <- c(
  "County", "Agency", "Population", "burglaries",
  "num_counties", "num_agencies", "murder_and_crime", "violent_crime",
  "property_crime"
)
wa_crime_df_mod <- wa_crime_df %>%
  select(all_of(cols_to_keep)) %>%
  rename_if(is.numeric, function(x) str_c(x, "_04"))

sample_design <- wa_crime_03_df %>%
  select(all_of(cols_to_keep)) %>%
  rename_if(is.numeric, function(x) str_c(x, "_03")) %>%
  right_join(wa_crime_df_mod) %>%
  filter(
    (County %in% non_king_county_sample |
      Agency %in% agency_sample)
  ) %>%
  mutate(
    strata_label = factor(if_else(County == "king", "strata 1", "strata 2")),
    num_counties = if_else(County == "king", 1, length(county_list) - 1)
  ) %>%
  as_survey_design(
    id = c(County, Agency),
    fpc = c(num_counties_04, num_agencies_04),
    strata = strata_label
  )

pop_03 <- wa_crime_03_df %>%
  summarize(P = sum(Population)) %>%
  pull(P)

previous_year_calibration <- calibrate(sample_design,
  formula = ~burglaries_03,
  population = c(
    "(Intercept)" = pop_size,
    "burglaries_03" = pop_03
  )
)
svytotal(~burglaries_04, previous_year_calibration)
```

Here I get an error message that one of the inner computations doesn't have
the correct dimensions. I suspect this is a bug in Lumley's code as the 
sampling design I constructed above isn't too complicated.

* d. Estimate the ratio of violent crimes to property crimes in the state, 
using the un-calibrated sample and the sample calibrated on population and 
number of burglaries.


```{r q7_1d}
strata_design %>%
  summarize(
    ratio = survey_ratio(violent_crime, property_crime)
  )
```

```{r q7_1d_, eval = FALSE}
svyratio(
  numerator = ~violent_crime_04,
  denominator = ~property_crime_04,
  design = previous_year_calibration
)
```

Again, the sample based estimator makes sense here, while the calibrated 
estimator has issues. So far this is my best understanding of how to apply
Lumley's code but I'll try to revisit this in the future.

2. Write an R function that accepts a set of 50 elephant weights and simulates
repeatedly choosing a single elephant and computing the Horvitz-Thompson and
ratio estimators of the total weight, reporting the mean and variance over
the repeated simulations. Explore the behavior for several sets of elephant 
weights. Verify that the Horvitz-Thompson estimator is always unbiased, but 
usually further from the truth than the ratio estimator.

```{r q7_2}
BasuHTE <- function(elephant_weights) {
  N <- length(elephant_weights)
  sambo <- which.min(abs(elephant_weights - mean(elephant_weights)))
  sample_probs <- rep((1 - 0.99) / (N - 1), N)
  sample_probs[sambo] <- 0.99
  # Okay to use the base R sample implementation here because we're only
  # sampling 1 item.
  x_ix <- sample(1:N, size = 1, prob = sample_probs)
  hte_weight <- 1 / sample_probs[x_ix] * elephant_weights[x_ix]
  ratio_estimate <- N * elephant_weights[x_ix]
  return(c("hte" = hte_weight, "ratio" = ratio_estimate))
}
elephant_is_male <- rbinom(50, size = 1, prob = 0.5)
elephant_weights <- elephant_is_male * rnorm(50, mean = 1.3E4, sd = 2E3) +
  (1 - elephant_is_male) * rnorm(50, mean = 6.6E3, sd = 1E3)
results <- as_tibble(t(replicate(1000, BasuHTE(elephant_weights)))) %>%
  mutate(rep_ix = 1:n()) %>%
  gather(hte, ratio, key = "estimator", value = "estimate") %>%
  group_by(estimator) %>%
  mutate(mean = mean(estimate), sd = sd(estimate)) %>%
  ungroup()
```

```{r q7_2_results}
true_total <- sum(elephant_weights)
results %>%
  ggplot(aes(x = estimate, fill = estimator)) +
  geom_histogram() +
  geom_vline(aes(xintercept = mean, color = estimator)) +
  geom_vline(aes(xintercept = true_total), linetype = 2, color = "red") +
  facet_wrap(~estimator, nrow = 2) +
  ggtitle("Illustrating Basu's Elephants")
```

```{r q7_2_unbiased}
results %>%
  filter(estimator == "hte") %>%
  summarize(average_estimate = mean(estimate)) %>%
  mutate(
    bias = average_estimate - true_total,
    truth = true_total
  )
```

From the plot above we can see that the horvitz thompson estimator is more
variable than the ratio estimator though both provide the appropriate estimate
on average.

3. Write an R function that accepts a set of 50 elephant weights and performs
the ranked set sampling procedure on page 150 to choose three of them. By
simulation, compare the bias and variance of the estimated total from ranked-set
sample to estimated totals from a simple random sample of three elephants.

```{r q7_3}
RankedSetSampleComparison <- function(elephant_weights) {
  srs_sample <- sample(elephant_weights, size = 3)
  sampling_weight <- length(elephant_weights) / 3
  srs_total <- sum(srs_sample * length(elephant_weights) / 3)
  rs_sample_one <- sample(elephant_weights, size = 3)
  rs_sample_two <- sample(elephant_weights, size = 3)
  rs_sample_three <- sample(elephant_weights, size = 3)
  rs_total <- rs_sample_one[which.min(rank(rs_sample_one))] * sampling_weight +
    rs_sample_two[which(rank(rs_sample_two) == 2)] * sampling_weight +
    rs_sample_three[which.max(rank(rs_sample_three))] * sampling_weight
  return(c("Ranked Set Estimate" = rs_total, "SRS Total" = srs_total))
}
results <- as_tibble(t(replicate(
  1000,
  RankedSetSampleComparison(elephant_weights)
))) %>%
  mutate(rep_ix = 1:n()) %>%
  gather(everything(), -rep_ix, key = "estimator", value = "estimate") %>%
  group_by(estimator) %>%
  mutate(mean = mean(estimate), sd = sd(estimate))
```

```{r}
results %>%
  ggplot(aes(x = estimate, fill = estimator)) +
  geom_histogram() +
  geom_vline(aes(xintercept = true_total), linetype = 2) +
  ggtitle("Ranked Set and Simple Random Sample Estimator Comparison")
```

As seen above the ranked set estimator has much lower variability, while 
maintaining the same mean estimate as compared to the simple random sample.

4. Estimate the proportions of people in CA with normal weight, overweight and 
obesity using the BRFSS 2007 data (X_STATE = 6, X_BMI4CAT = BMI). Post-stratify
the CA data to have the same age and sex distribution as the data for FL 
(X_STATE = 12) and compute the directly standardized estimates based on CA
data to estimates form the data for FL to see if the differences in BMI 
between the states are explained by differences in age distribution.

```{r q7_4}
db <- DBI::dbConnect(RSQLite::SQLite(), "Data/BRFSS/brfss07.db")
brfss_ca <- tbl(db, sql("SELECT * FROM brfss")) %>%
  filter(X_STATE == 6) %>%
  collect() %>%
  mutate(
    BMI_Cat = case_when(
      X_BMI4CAT == 1 ~ "Normal BMI",
      X_BMI4CAT == 2 ~ "Overweight BMI",
      X_BMI4CAT == 3 ~ "Obese BMI",
      TRUE ~ NA
    )
  ) %>%
  as_survey_design(
    id = X_PSU, strata = X_STATE, weight = X_FINALWT,
    nest = TRUE
  )

brfss_ca %>%
  group_by(BMI_Cat) %>%
  summarize(
    proportion = survey_mean()
  )
```

```{r q7_4_poststratify}
brfss_fl <- tbl(db, sql("SELECT * FROM brfss WHERE X_STATE == 12")) %>%
  collect() %>%
  mutate(
    BMI_Cat = case_when(
      X_BMI4CAT == 1 ~ "Normal BMI",
      X_BMI4CAT == 2 ~ "Overweight BMI",
      X_BMI4CAT == 3 ~ "Obese BMI",
      TRUE ~ NA
    )
  ) %>%
  as_survey_design(
    id = X_PSU, strata = X_STATE, weight = X_FINALWT, nest = TRUE
  )

fl_sex_age_totals <- brfss_fl %>%
  group_by(SEX, X_AGE_G) %>%
  survey_count() %>%
  select(-n_se) %>%
  rename(Freq = n)

postStratify(
  design = brfss_ca, strata = ~ SEX + X_AGE_G,
  population = fl_sex_age_totals
) %>%
  svymean(~BMI_Cat, design = ., na.rm = TRUE)
```


```{r q7_4_og_stratify}
brfss_fl %>%
  group_by(BMI_Cat) %>%
  summarize(
    proportion = survey_mean()
  )
```

In general we see that the two estimates - the post stratified estimate and the
"direct" estimates largely agree, for the proportion of Obese and Overweight
BMI estimates. The normal BMI Estimates appear to be substantially different 
which may be due to factors that aren't unaccounted for in the age and sex 
strata.

5. Consider a categorical post-stratification variable with $K$ categories
having as population counts $N_1, N_2,...N_K$. Suppose we are interested in 
estimating the total of a variable $Y$.

* a. Show that the post-stratified estimate is 
$$
\hat{T}_{ps} = \sum_{k=1}^{K} N_k \hat{\mu}_k,
$$

where $\hat{\mu}_k$ is the estimated mean of $Y$ in group $K$ before 
post-stratification.

We'll start with using the result derived in the text that shows when we 
post-stratify we scale the weights, $\pi_i^* = \frac{g_i}{\pi_i}$, such that
the estimated strata size is exactly equal to the known (post) strata size. 
This results in a $g_i = \frac{N_k}{\hat{N_k}}$ scaling weight.

For our post-stratified total estimate then we have
$$
\hat{T}_{ps} = \sum_{i=1}^{n} y_iI(y_i \in S_k) \frac{N_k}{\hat{N}_k} \\
= \sum_{k=1}^{K} \hat{\mu}_k N_k
$$
Where the mean estimate, $\hat{\mu}_k$ comes from dividing the $y_i$ in each 
$k$ group by the $\hat{N}_k$ denominator.


* b. Show that the regression estimate from a model with indicator variables
for each group is also 

$$
\hat{T}_{reg} = \sum_{k=1}^{K} N_k \hat{\mu}_k
$$

This follows in a straightforward fashion from a regression model set-up. If we
fit the following model:
$$
E[Y_i] = \beta_k I(y_i \in S_k)
$$
Then it follows that 
$$
\hat{\beta}_k = \hat{\mu}_k = \frac{1}{n_k} \sum_{i=1}^{n}y_iI(y_i \in S_k), k = 1,...,K
$$
Predicting a new total then with the new counts re-weighted amounts to a 
regression prediction 
$\hat{T}_{ps} = \sum_{k=1}^{K} N_k \hat{\beta}_k = \sum_{k=1}^{K} N_k \hat{\beta}_k$

# Chapter 8: Two-Phase Sampling

## MultiStage and Multiphase Sampling

In comparison to multistage sampling, where individuals or clusters were sampled
independently of one another across stages, multiphase sampling is a design
where individuals are sampled dependent upon information obtained in the first
sample. Consequently, instead of having two sampling probabilities which are
multiplied by each other $\pi_1 \times \pi_2$ we have conditional weights
$\pi_1$ and $\pi_{2|1}$ which describe the probability of an entity being
sampled in phase one and the the probability of a phase being sampled in stage
two, conditional on being sampled in phase one. Multiplying and differencing
these two probabilities together can be used to construct an estimator very
similar to the horvitz-thompson estimator, though is theoretically distinct.
Lumley notes here that his software and exposition only covers the simple cases 
of both types of sampling designs described here can be expanded to cover 
multiple phases and combinations of both types of designs.

## Sampling for Stratification

One common motivation for two-phase sampling is to measure some strata variable
on a sample of the populations. The first phase sample is a random sample of 
the general population on which the strata variable is then measured. The second
phase of sampling then stratifies on this variable for greater precision.

Lumley gives several examples of this setup including the NHANES and NHIS 
surveys. Though the data associated with these are not made publicly available,
unfortunately.


## The Case-Control Design

> A type of sampling for stratification is the case-control design
(or choice-based design in economics).

This design is used when the measure of interest is particularly sparse or rare
in the population. The basic setup is the same as described in the previous 
section where the rare disease is measured in the first phase sample from a 
hopefully well specified population. The second phase samples all individuals
with the disease (cases) and some proportion of the controls. Typically matching
$k$ controls to each case.

A few brief notes Lumley makes here:

1. If done properly, the design effect is very large for this design; this 
design is far more efficient than a simple random sample proportional to the 
sparsity of the disease.
2. Two competing interests in selecting controls that leads to criticism of this
design --- they have to be representative of the population, but also good
"matches" for the cases. They need to be comparable in some way.
3. Design based inference was not as frequently used for case control designs.
  -- Because the odds ratio estimate is independent of the sampling fraction and
the estimated standard errors are typically less, a model based approach is
often used. However, this requires the model to be specified correctly 
which is not always the case. 
  -- Lumley notes that there seems to be less hesitancy about using either
  design based approach or a model based approach as there once was. 

### Oesophageal cancer in Ille-et-Vilaine


Lumley re analyzes data published as part of a previous study 
[@breslow1980statistical] [@aj1977cancer] looking at esophageal cancer in 
northwest France as impacted by of alcohol and tobacco consumption.

Lumley gets a control sampling weight of 441 by digging around in the related
papers and uses this to expand the original dataset, which contains the 
aggregate numbers to construct a survey design object below.
```{r esoph_demo}
cases <- cbind(esoph[rep(1:88, esoph$ncases), ], case = 1, weight = 1)
controls <- cbind(esoph[rep(1:88, esoph$ncontrols), ], case = 0, weight = 441)
esoph.x <- rbind(cases, controls)
d_esoph <- svydesign(
  id = ~1, strata = ~case, weights = ~weight,
  data = esoph.x
)
unwtd <- glm(case ~ agegp + as.numeric(tobgp) + as.numeric(alcgp),
  data = esoph.x, family = binomial()
)
wtd <- svyglm(case ~ agegp + as.numeric(tobgp) + as.numeric(alcgp),
  design = d_esoph, family = quasibinomial
)
coef(unwtd)[7:8]
coef(wtd)[7:8]
SE(unwtd)[7:8]
SE(wtd)[7:8]
```

```{r esoph_demo_2}
tbl_merge(
  tbls = list(tbl_regression(unwtd), tbl_regression(wtd)),
  tab_spanner = c("**Unweighted**", "**Weighted**")
)
```


Regardless of which model is used, both show that tobacco and alcohol use 
increases the odds of esophageal cancer, though the un-weighted model does have
slightly smaller confidence intervals for the coefficients of interest,
as we can see in the table above.

### Simulations: efficiency of the design-based estimator

In this section Lumley computes the relative efficiency of the weighted 
estimator relative to the weighted comparing different distributions of 
cases and controls. Lumley defines the relative efficiency as the 
number of observations needed to produce the same accuracy but it isn't clear
how accuracy is measured here (length of standard error?). Since he doesn't
show how he computes the resulting table, I've omitted his example from my 
notes.



### Frequency matching

> Many case-control designs use a further level of stratification and unequal 
sampling in the phase-two sample, a practice known in the epidemiology 
literature as *frequency matching*.  

The idea is to avoid wasting cases / controls in regions of low exposure. 
Lumley uses the example of the oesphageal cancer study to illustrate. Bracket
text below is mine:

> ... very little information about the effects of alcohol and tobacco is 
present in the youngest age group, because there is only one case. If the 
associations with age had already been understood and the study had been 
designed to estimate the effect of alcohol and tobacco [only] this would be an
inefficient design that effectively wasted 116 controls. A more efficient
design would saple more controls at older ages and end up with five controls 
per case in each age group rather than five controls per case on average over 
all ages.

Lumley goes on to say that frequency matching isn't the most efficient way to
use the age information, but he doesn't say what would be. I'm guessing he's
thinking of further stratification or unequal sampling but I can't be sure. 


## Sampling from Existing Cohorts

Lumley notes in this section that it is often advantageous in larger
randomized control trials or cohort studies to subsample once certain 
measurements have been taken. Lumley gives an account of methods used on these
data --- previously nested case control designs, ignoring the phase one sample 
and cohort representativeness but more recently stratifying on both outcome and 
covariates in phase two and post-stratifying to the original cohort. 
The trade-offs between model and design based approaches are/were not clear
at the date of publication in this setting. My take is that the design based
approach seems better given how many design elements are involved in the
construction of the study.

### Logistic regression

|         | Exposed | Unexposed |
|---------|---------|-----------|
| Case    | a       | b         |
| Control | c       | d         |
| Total   | a+c     | b + d     |

Lumley's goal in this section is to show how case control designs can be 
optimised to reduce the variance associated with the odds ratio estimate, 
typically estimated via logistic regression. Starting from a 2 x 2 contigency 
table like that shown above the variance of the log of the  odds ratio can be
estimated as follows:

$$
V[\log \psi] = \frac{1}{a} + \frac{1}{b} + \frac{1}{c} + \frac{1}{d},
$$

where $\psi$ represents the odds of the disease in the exposed cases vs the
odds of disease in the exposed controls. From the expression above, we see that
if we increase any of the cell counts, we decrease the variance. However,
a classic case control design will only control the table row margins, meaning
there might be greater improvement in controlling the sampling from the 
exposure covariate(s) as well. 

However, in that setting the classic logistic regression model no longer gives
a valid analysis because the odds ratio will be impacted by the unequal 
sampling fractions amongst the exposure covariate. In that case, a design based
approach is necessary. 

Lumley uses the National Wilms Tumor Study group to illustrate this idea. 
Kidney histology was available for all members of the study. Although the 
initial histology had an appreciable error rate, it could still be used to 
sample from. Though Lumley does not give an exact procedure for how he does this
he shows a table of of biased sampling that includes 183 controls with 
unfavorable histology ratings, a higher number than what would be included with
random sampling matched case-control procedure.


### Two-phase case-control designs in R

Lumley illustrates how to fit a two-phase sample estimate using the national
wilms tumor study data. The code and model output are below.

```{r nwts_2phase_demo}
nwts <- addhazard::nwtsco
set.seed(1337)
subsample <- with(nwts, c(
  which(relaps == 1 | instit == 1),
  sample(which(relaps == 0 & instit == 0), 499)
))
nwts$in.subsample <- (1:nrow(nwts)) %in% subsample
nwts_design <- twophase(
  id = list(~1, ~1), subset = ~in.subsample,
  strata = list(NULL, ~ interaction(instit, relaps)),
  data = nwts
)
nwts_design
```

```{r nwts_ccs_demo}
set.seed(1337)
casectrl <- with(nwts, c(which(relaps == 1), sample(which(relaps == 0), 699)))
nwts$in.ccs <- (1:nrow(nwts)) %in% casectrl
ccs_design <- twophase(
  id = list(~1, ~1), subset = ~in.ccs,
  strata = list(NULL, ~relaps), data = nwts
)
m1 <- svyglm(relaps ~ histol * stage + age + tumdiam,
  design = nwts_design,
  family = quasibinomial()
)
m2 <- svyglm(relaps ~ histol * stage + age + tumdiam,
  design = ccs_design,
  family = quasibinomial()
)
m3 <- glm(relaps ~ histol * stage + age + tumdiam,
  data = nwts, subset = in.ccs,
  family = binomial()
)
m1a <- svyglm(relaps ~ histol * stage + age + tumdiam,
  design = nwts_design,
  family = quasipoisson(log)
)
m2a <- svyglm(relaps ~ histol * stage + age + tumdiam,
  design = ccs_design,
  family = quasipoisson(log)
)
```

```{r}
tbl_merge(
  tbls = list(
    tbl_regression(m1, conf.int = FALSE),
    tbl_regression(m2, conf.int = FALSE),
    tbl_regression(m3, conf.int = FALSE),
    tbl_regression(m1a, conf.int = FALSE),
    tbl_regression(m2a, conf.int = FALSE)
  ),
  tab_spanner = c(
    "Two Phase Design based Odds Ratio",
    "CC Design Based Odds Ratio",
    "Model Based Odds Ratio",
    "Two Phase Design Based Relative Risk",
    "CC Design Based Relative Risk"
  )
)
```

Few quick things to note:

1. The estimates between the relative risk rate ratio and odds ratio vary 
substantially, as we'd expect.
2. There is an appreciable precision gain in the `histol` x `stage` estimates 
comparing the design based to the model based, with a slight gain from using 
the `instit` for sampling in the more general two-phased sampling model.
3. Lumley notes that model based analysis are also available for two-phased 
samples. In my training we learned how to use a conditional logistic regression
in this setting. You can see a similar example 
[here](https://www.bookdown.org/rwnahhas/RMPH/blr-conditional.html).


### Survival Analysis

In this section Lumley briefly introduces the concept of the case-cohort study,
as well as the topic of survival analysis. Notes on each below.


**Case-Cohort Study**

* A two phase sample in which the the second phase sample is a sub-cohort chosen
at the beginning in addition to all cases identified during follow-up.
* Lumley notes that this initial sub-cohort can be used for comparing against
multiple types of measured "cases" or events, in contrast to a case-control 
design which is constrained to analysis of the single type of case.


**Survival Analysis**

* Survival analysis is a large enough topic to be given its own book but here
Lumley focuses on the Cox proportional hazards model, which estimates
the hazard function, or instantaneous rate of an event (like cancer relapse) 
occuring as a function of some covariates.

* Notably, survival analysis incorporates assumptions for censoring, or the 
unobservance of the event occuring within the follow-up period.

#### Case Cohort Designs

Lumley uses the Wilms Tumor study again, to illustrate how a case-cohort 
analysis can be used to estimate patients survival from Wilms tumor as a 
function of the measured covariates. Here's the setup in Lumley's own words:

> For the classical case-cohort analysis we take a sample from the cohort at the
start of the followup and then add all the cases to it. If the expected event
rate is about 1 in 7, giving about 650 expected cases, and we want 650 non-cases,
this means sampling a subcohort of 650 x 7/6 or about 750... Under this 
sampling design there are two sampled strata: those in the subcohort and those
not in the subcohort. The sampling probabilities are $\pi_{(2|1)} = 750 / 3915$
for the subcohort and $\pi_{(2|1)} = 1$ for cases not in the subcohort.

The code is below.

```{r wilms_case_cohort}
set.seed(1729)
subcohort <- with(nwts, sample(1:nrow(nwts), 750))
cases <- which(nwts$relaps == 1)
nwts$in.cchsample <- (1:nrow(nwts)) %in% c(subcohort, cases)
nwts$in.subcohort <- (1:nrow(nwts)) %in% subcohort
nwts$wts <- ifelse(nwts$in.subcohort, 3915 / 750, 1)
cch_design <- twophase(
  id = list(~1, ~1), subset = ~in.cchsample,
  strata = list(NULL, ~in.subcohort),
  weights = list(NULL, ~wts),
  method = "approx",
  data = nwts
)

s1 <- svycoxph(Surv(trel, relaps) ~ histol * stage + age + tumdiam,
  design = cch_design
)

cch_data <- subset(nwts, in.cchsample)
cch_data$id <- 1:nrow(cch_data)
# "classic" analysis based only on phase 2 data
s2 <- cch(Surv(trel, relaps) ~ histol * stage + age + tumdiam,
  id = ~id,
  data = cch_data, subcoh = ~in.subcohort, cohort.size = 3915
)
tbl_merge(
  tbls = list(tbl_regression(s1), tbl_regression(s2)),
  tab_spanner = c(
    "**Case-Cohort Analysis**",
    "**Classic Phase 2 Analysis**"
  )
)
```

Looking at the table above, we can see that there's a decent amount of 
disagreement between the two estimates. Lumley argues this is because of the 
poor fit of the cox model. An assumption that's necessary for the Cox model
to fit well is that the hazards functions are proportional across time. 
As we see in the plot below and in the text, the hazard estimate for age is
lower earlier in the trial than later on.

```{r cox_ph_check_plot}
plot(cox.zph(s1), var = "age")
```

Lumley notes that the case-cohort analysis could just as easily be framed as
a stratified sample on cases in the second phase. The code below performs this
analysis --- again using both case and case + institution for the stratifying
variables. The last bit of code extracts the variance estimates that's from
each phase of sampling and computes how much of the variance comes from the
first phase as opposed to the second phase for each of the estimated 
coefficients.

```{r stratified-case-cohort-sample}
scch_design <- twophase(
  id = list(~1, ~1), subset = ~in.cchsample,
  strata = list(NULL, ~relaps), data = nwts
)

s1 <- svycoxph(Surv(trel, relaps) ~ histol * stage + age + tumdiam,
  design = scch_design
)
nwts_design <- twophase(
  id = list(~1, ~1), subset = ~in.subsample,
  strata = list(NULL, ~ interaction(instit, relaps)),
  data = nwts
)
s2 <- svycoxph(Surv(trel, relaps) ~ histol * stage + age + tumdiam,
  design = nwts_design
)


v1 <- vcov(s1)
v2 <- vcov(s2)

rbind(
  diag(attr(v1, "phases")$phase2 / attr(v1, "phases")$phase1),
  diag(attr(v2, "phases")$phase2 / attr(v2, "phases")$phase1)
)
```


```{r case-cohort-comp-table}
s3 <- coxph(Surv(trel, relaps) ~ histol * stage + age + tumdiam,
  data = nwts
)
tbl_merge(
  tbls = list(
    tbl_regression(s1),
    tbl_regression(s2),
    tbl_regression(s3)
  ),
  c(
    "**Stratified Case Cohort**",
    "**Stratified Case Cohort - Institution**",
    "**Full Data**"
  )
)
```

The above table contains the data from both of the stratified case-cohort 
analyses as well as a model fit to the full data. The case-institution 
stratified analysis is more efficient than only the case stratified analysis.
Both design based analyses agree with the full data analysis, though, of course,
the full data analysis has less variability. Interestingly though, it is not
that much better than the stratified case-cohort-institution estimates.

## Using Auxiliary Information from Phase 1

In this section Lumley reviews how information recorded on individuals during
the first phase can be used to improve the precision of estimates in the second
phase via calibration. Lumley differentiates the use of auxiliary information
here as compared to chapter 7's review of post-stratification, raking 
and calibration by noting the following 3 differences:

1. The Phase one data includes individual level auxiliary variables.
2. Re-weighting can be customized to a particular analysis.
3. There may be --- when sampling from a cohort --- a large number of auxiliary 
variables available.

With this set-up Lumley discusses how to construct more effective auxiliary 
variables using influence functions.

### Population calibration for regression models

Lumley motivates his discussion of influence functions with the api data, where
we can reference the full population data.

Lumley's description of influence functions are intentionally simple, 
describing them as 

> "The influence function for an estimate $\hat{\beta}$ describes how the 
estimate changes when observations are added to or removed from the data."

For linear, glms, and cox models, these are $\Delta\beta$ deletion diagnostics
that are often taught as part of the statistics curriculum covering the 
subjects.  For example, a simple linear regression has the following influence
function for the slope parameter:
$$
\mathcal{I}(x_i, y_i; \beta) = \frac{1}{\pi_i}\frac{1}{V[X]}(x_i - \bar{x})(y_i - \mu_i(\beta)),
$$

where $\mu_i(\beta)$ is the fitted value for the $i$th observation. Lumley
reasons that 

> If an auxiliary variable $Z$ is highly correlated with $Y$ it will have a low 
correlation with $\mathcal{I}$, because the multiplier $(x_i - \bar{x}) can be
negative or positive with about equal probability.

I don't quite see how Lumley is drawing the connection that
$Cor(Y,Z) \approx 1 \implies Cor(Z,\mathcal{I}) \approx 0$ unless there is some
way that $Z$'s impact on $Y$ is through $X$ --- epidemiologists would then say
"The effect of $Z$ on $Y$ is mediated by $X$. I don't that's what Lumley's 
referring to here...

The next part makes sense - Lumley says that in order to construct new 
variables for use in calibration, we can use the influence functions from
linear regressions constructed from $Z \tilde X$. Though I should say, it 
isn't clear to me *why* we might choose $Z$ as the regression variable here...

In any case, Lumley demonstrates this with the api data, using the full
population data to estimate the influence functions.


```{r influence_functions_demo}
m0 <- svyglm(api00 ~ ell + mobility + emer, clus1_design)
var_cal <- calibrate(clus1_design,
  formula = ~ api99 + ell + mobility + emer,
  pop = c(6194, 3914069, 141685, 106054, 70366),
  bounds = c(0.1, 10)
)
m1 <- svyglm(api00 ~ ell + mobility + emer, design = var_cal)


popmodel <- glm(api99 ~ ell + mobility + emer,
  data = apipop,
  na.action = na.exclude
)

inffun <- dfbeta(popmodel)
index <- match(apiclus1$snum, apipop$snum)
clus1if <- update(clus1_design,
  ifint = inffun[index, 1],
  ifell = inffun[index, 2], ifmobility = inffun[index, 3],
  ifemer = inffun[index, 4]
)
if_cal <- calibrate(clus1if,
  formula = ~ ifint + ifell + ifmobility + ifemer,
  pop = c(6194, 0, 0, 0, 0)
)

m2 <- svyglm(api00 ~ ell + mobility + emer, design = if_cal)
tbl_merge(
  tbls = list(
    tbl_regression(m0, intercept = TRUE),
    tbl_regression(m1, intercept = TRUE),
    tbl_regression(m2, intercept = TRUE)
  ),
  tab_spanner = c("Cluster Design", "Calibrated", "Influence Calibrated")
)
```

We can see the precision in the estimates gets better as we move from the 
sampled model to the influence calibrated model. 

These can obviously get much more complex for more complex models.
For more theory Lumley refers the reader to [@breslow1980statistical]. 

### Two-phase designs

The best case for using influence functions as above in a two-phase design is
when a phase-one variable is correlated with the variable of interest measured
in phase two. Lumley gives an example for when this might occur: Self-reported
smoking at phase one then followed up by a urinary test in phase two. In this
setting Lumley proposes the following approach for constructing auxiliary 
variables based on influence functions.

1. Build an imputation model to predict the phase-two variable from the 
phase-one variables.

2. Fit a model to all of phase one, using the imputed value for observations 
that are not in the phase-two sample.

3. Use the influence functions from this model as auxiliary variables in 
calibration.

In the API example, the imputation model step was replaced by using the previous
year's API test values.


#### Example: Wilms' tumor

Lumley walks through [@breslow2009using]'s analysis of the NWTS data 
illustrating this approach. Lumley walks through the analysis in the text which 
has a clear mapping to the three steps above so I won't repeat him. The code to
fit the imputation model and calibrations are shown below.

```{r NWTS_inf_2phase}
impmodel <- glm(histol ~ instit + I(age > 10) + I(stage == 4) * study,
  data = nwts, subset = in.subsample, family = binomial()
)

nwts$imphist <- predict(impmodel, newdata = nwts, type = "response")

nwts$imphist[nwts$in.subsample] <- nwts$histol[nwts$in.subsample]

ifmodel <- coxph(Surv(trel, relaps) ~ imphist * age + I(stage > 2) * tumdiam,
  data = nwts
)

inffun <- resid(ifmodel, "dfbeta")

colnames(inffun) <- paste("if", 1:6, sep = "")
nwts_if <- cbind(nwts, inffun)
if_design <- twophase(
  id = list(~1, ~1), subset = ~in.subsample,
  strata = list(NULL, ~ interaction(instit, relaps)),
  data = nwts_if
)

if_cal <- calibrate(if_design,
  phase = 2, calfun = "raking",
  formula = ~ if1 + if2 + if3 + if4 + if5 + if6 +
    relaps * instit
)

m1 <- svycoxph(Surv(trel, relaps) ~ histol * age + I(stage > 2) * tumdiam,
  design = nwts_design
)

m2 <- svycoxph(Surv(trel, relaps) ~ histol * age + I(stage > 2) * tumdiam,
  design = if_cal
)
m3 <- coxph(Surv(trel, relaps) ~ imphist * age + I(stage > 2) * tumdiam,
  data = nwts
)
m4 <- coxph(Surv(trel, relaps) ~ histol * age + I(stage > 2) * tumdiam,
  data = nwts
)

tbl_merge(
  tbls = list(
    tbl_regression(m1),
    tbl_regression(m2),
    tbl_regression(m3),
    tbl_regression(m4)
  ),
  tab_spanner = c(
    "2-Phase Weighted",
    "2-Phase Raked",
    "2 Phase Imputed",
    "Full Data"
  )
)
```

As expected we see that the raking and imputation - influence model have
the lowest standard errors. Lumley notes that this is often the case when the
imputation model is very good, further stating that the raking approach has
the advantage of always being valid, while the calibration depends on correct
modeling.

### Some history of the two phase calibration estimator

Here Lumley gives a brief overview of the history of calibration and 
augmented inverse-probability model based estimators, which were developed in
parallel and have a large amount of overlap.

I'd like to raise some questions I found myself asking as I read this last
section on using auxiliary information from phase 1.

1. The first concerns uncertainty estimates. Lumley doesn't mention it, but the
use of an imputation model should incorporate greater uncertainty into our final
estimates. It doesn't look like his software makes any effort to incorporate
that uncertainty or how optimistic our final standard errors might be.


2. The use of influence functions remind me of, but are not exactly similar to
dimensionality reduction methods, like 
[principle components analysis](https://en.wikipedia.org/wiki/Principal_component_analysis)
I can't help but wonder if there's a way to reduce many of the influence functions
to a few variables, or if some penalization methods would be required in the 
case of constructing *many* influence functions

3. As I mentioned earlier, it isn't clear how we choose which variables should
be regressed upon the influence function set-up. Why impute histology as opposed
to tumor stage? Is it because it's the most strongly associated with the 
outcome? How is someone supposed to know this in practice or *a priori*?

Overall I'm glad that Lumley included this subject in his book as its very 
important but there were a lot of questions I feel still needed answering in 
this last section.


## Questions

1.  Suppose a phase one simple random sample of size $n$ is taken from a 
population of size $N$, to measure a variable $X$ with $G$ categories. Write 
$N_1, N_2, ..., N_G$ for the (unknown) number of individual in the population in
each category, and $n_1,...,n_g$ for the number in the phase one sample. The 
phase-two sample takes a fixed number $m$ from each category. Show that 
$\pi_i^*$, $\pi_{ij}^*$ for this design approach $\pi_i$ and $\pi_{ij}$ for a
stratified sample from the population as $n$ increases.

I'll start with defining the weights in stratified sample design for an 
arbitrary strata $g$. The sampling probability $\pi_i = \frac{m}{N_g}$ and
the co-sampling probability is $\pi_{ij} = \frac{m}{N_g}(m-1)(N_g - 1)$. 
These values can be found from Chapter 2 question 10.

From the beginning of chapter 8 we have that 
$\pi_{i}^* = \pi_{i1} \times \pi_{i(2|1)}$ and the same is true for the 
co-inclusion probabilities. In which case we have $\pi_{i1} = \frac{n}{N}$
and $\pi_{i(2|1)} = \frac{m}{n_g}$. Which gives us
$$
\pi_{i*} = \frac{n}{N}\frac{m}{n_g}
$$
I'm not sure my notation is set up exactly right to answer Lumley's question
but I can reason my way there.

As $\n \to N$ we'll have more and more of the population in our first phase 
sample or in other words the first stage sampling probability will be 1 ; 
$\frac{N}{N} = 1$. In which case we're sampling from a strata with known strata 
size, $N_g$ which is equivalent to the sampling probability we saw before.

For the coinclusion probability we have a similar phenomenon where $n\toN$
results in a leading factor becoming $1$.

$$
\pi_{ij,1} = \frac{n}{N}(n-1)(N-1) \\ 
\pi_{ij,(2|1)} = \frac{m}{n_g}(m-1)(n_g-1) \\
\implies \pi_{ij}^* = \frac{n}{N}(n-1)(N-1)\frac{m}{n_g}(m-1)(n_g-1)
$$

As $n \to N$ we have 
$$
\pi_{ij}^* \stackrel{n\to N}{=} 1 \times (N-1)^2 \frac{m}{N_g}(m-1)(N_g - 1) \\
= \frac{m}{N_g}(m-1)(N_g - 1) (N - 1)^2
$$
which is the same except for the $(N-1)^2$ constant. I'm wondering if this
sampling probability assumes sampling with replacement... otherwise the 
conclusion probability should simplify --- easily --- to 1, the same as for
$\pi_i$, the only way you'd have any probability of sampling two things together
being more than 1, is if you were sampling with replacement...


2. Construct a full two-phase data set for the Ille-et Vilaine case-control 
study.The additional phase-one observations are 430000-975 controls to make the
number up to the population size. Fit the logistic regression model using the
design produced by `twophase()` and compare the results to the weighted 
estimates in Figure 8.1.

```{r q8_2}
cases <- cbind(esoph[rep(1:88, esoph$ncases), ], case = 1, weight = 1)
controls <- cbind(esoph[rep(1:88, esoph$ncontrols * 441), ], case = 0, weight = 1)
esoph_full <- rbind(cases, controls) %>%
  mutate(
    ix = 1:n(),
    in_second_phase = if_else(case == 1 | case == 0 & ix %% 441 == 1, TRUE,
      FALSE
    )
  )

twop_design <- twophase(list(~1, ~1),
  strata = list(NULL, ~case),
  subset = ~in_second_phase,
  data = esoph_full
)

fit <- svyglm(case ~ agegp + as.numeric(tobgp) + as.numeric(alcgp),
  design = twop_design, family = quasibinomial()
)

tbl_merge(
  tbls = list(
    tbl_regression(unwtd), tbl_regression(wtd),
    tbl_regression(fit)
  ),
  tab_spanner = c("**Unweighted**", "**Weighted**", "**Two Phase**")
)
```

We can see from the table above that the two phase and weighted results are
effectively the same. This makes sense, given the large size of the phase one
sample.

3. This exercise uses the WA State crime data for 2004 as the population. The 
data consist of crime rates and population size for the police districts and
sheriffs offices grouped by county.

```{r q83_data}
wa_crime_df <- readxl::read_xlsx("data/WA_crime/1984-2011.xlsx",
  skip = 4
) %>%
  filter(Year == "2004", Population > 0) %>%
  mutate(
    murder = `Murder Total`,
    murder_and_crime = `Murder Total` + `Burglary Total`,
    violent_crime = `Violent Crime Total`,
    burglaries = `Burglary Total`,
    property_crime = `Property Crime Total`,
    state_pop = sum(Population),
    County = stringr::str_to_lower(County),
    num_counties = n_distinct(County),
  ) %>%
  group_by(County) %>%
  mutate(num_agencies = n_distinct(Agency)) %>%
  ungroup() %>%
  select(
    County, Agency, Population, murder_and_crime, murder, violent_crime,
    property_crime, burglaries, num_counties, num_agencies
  )
```

  * Take a simple random sample of 20 police districts from the state and use
  all the data from the sampled counties. Estimate the total number of murders
  and burglaries in the state
  
Not clear what Lumley means here, given that he first says to sample at the 
police district level but then says to use all the data at the county level...

Given this mix up I proceed assuming he meant that we should sample at the
county level and then use all the data for those counties.

```{r q8_3_a}
set.seed(35315)
county_sample <- wa_crime_df %>%
  distinct(County) %>%
  slice_sample(n = 20) %>%
  pull(County)

wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  ) %>%
  summarize(
    total = survey_total(murder_and_crime, vartype = "ci", deff = TRUE)
  )
```

  * Calibrate the sample in the previous question using population as the 
  auxiliary variable and estimate the total number of murders and burglaries in 
  the state.
  
```{r q8_3_b}
srs_design <- wa_crime_df %>%
  filter(County %in% county_sample) %>%
  as_survey_design(
    ids = c(County, Agency),
    fpc = c(num_counties, num_agencies)
  )

calibrated_srs_design <- calibrate(srs_design,
  formula = ~1,
  population = sum(wa_crime_df$Population)
)

svytotal(~murder_and_crime, calibrated_srs_design)
```

My use of the `calibrate()` function continues to spit out ridiculous numbers.
I'll try to debug this later but for now all I can say is that my cursory look
through the documentation for the function doesn't show any egregious misuse.
  
  * Take a simple random sample of 100 police districts as phase one of a two
  phase design, and assume that population is the only variable available at
  phase one. Divide the sample into 10 strata with roughly equal total 
  population and sample two police districts from each stratum for phase two.
  Estimate the total number of murders and of burglaries in the state.
  
```{r q8_3_c}
set.seed(33531)
p1_sample <- wa_crime_df %>%
  distinct(Agency) %>%
  slice_sample(n = 100) %>%
  pull(Agency)

p1_pop <- wa_crime_df %>%
  filter(Agency %in% p1_sample) %>%
  pull(Population)
p1_pop_quantiles <- quantile(p1_pop, seq(from = 0, to = 1, length.out = 10))

p2_sample <- wa_crime_df %>%
  filter(Agency %in% p1_sample) %>%
  mutate(strata = cut(Population,
    breaks = p1_pop_quantiles,
    include.lowest = TRUE
  )) %>%
  select(Agency, strata) %>%
  group_by(strata) %>%
  slice_sample(n = 2) %>%
  ungroup() %>%
  pull(Agency)

twop_design <- wa_crime_df %>%
  filter(Agency %in% p1_sample) %>%
  mutate(
    strata = cut(Population, breaks = p1_pop_quantiles, include.lowest = TRUE),
    in_phase_two = Agency %in% p2_sample,
    fpc_one = 234,
  ) %>%
  group_by(strata) %>%
  mutate(fpc_two = n()) %>%
  ungroup() %>%
  as_survey_twophase(
    id = list(Agency, Agency),
    strata = list(NULL, strata),
    subset = in_phase_two,
    fpc = list(fpc_one, fpc_two)
  )

twop_design %>%
  summarize(
    total = survey_total(murder_and_crime, deff = TRUE)
  )
```

We see a much lower uncertainty around the total estimate of the number of
murders and crimes relative to the previous design. This is especially
exemplified in the design effect.
  
  * Calibrate the two phase sample using the phase-one population size data.
  Estimate the total number of murders and of burglaries in the state.

```{r q8_3_d}
twop_calibration <- calibrate(twop_design, ~Population,
  phase = "2"
)
svytotal(~murder_and_crime, twop_calibration, deff = TRUE)
```

Here at least the number makes sense, though it looks like the standard error
has increased relative to the standard two phase design. This might be because
the population information is already encoded in the strata design of the 
second phase of sampling.

  
4. The sampling probabilities $\pi$ and $\pi^*$ in the NWTS two phase 
case-control study depend on the 2 x 2 table of relaps and instit. Suppose that 
the super population probabilities for the cells in the 2 x 2 table match those
in Table 8.3.

 * Write R code to simulate realizations of Table 8.3 and to compute the second
 phase sampling probabilities $\pi_{i(2|1)}$ for a two-phase design with sample
 size 1300 and cell counts as equal as possible. That is, sample everyone in a 
 cell that has fewer than 1300 people and then divide the remaining sample size 
 evenly over the remaining cells.
 
I see a lot of ways to conduct the second phase sampling that could be 
influential on the results. For example, do we try to ensure that the cell
counts are as equal as possible, even at the expense of throwing away sample 
size? Or should we take as many samples as we can get even if it results in
more unequal cell counts.
 
```{r 8q4_a}
probs <- c(
  "Relapse_Unfav" = 194 / 3915, "Relapse_Fav" = 475 / 3915,
  "Control_Unfav" = 245 / 3915, "Control_Fav" = 3001 / 3915
)
probs_df <- as_tibble(t(probs)) %>%
  gather(everything(), key = "Cell", value = "pi_one")
sims <- t(rmultinom(1000, size = 3915, prob = probs)) %>%
  as_tibble() %>%
  mutate(sim_ix = 1:n()) %>%
  gather(everything(), -sim_ix, key = "Cell", value = "Count") %>%
  arrange(sim_ix, Count) %>%
  group_by(sim_ix) %>%
  mutate(
    cell_rank = min_rank(Count),
    initial_sample = sum((cell_rank == 1) * Count),
    remaining_sample = (1300 - initial_sample) / 3,
    twop_sampling_probability = case_when(
      # sample everything from smallest cell with probability 1
      cell_rank == 1 ~ 1,
      remaining_sample > Count ~ 1,
      remaining_sample < Count ~ remaining_sample / Count
    )
  ) %>%
  left_join(probs_df) %>%
  mutate(pi_star = pi_one * twop_sampling_probability)
```
 
 
 * Run 1000 simulations, compute $\pi_i$ as the average of $\pi_i^*$ for a given
 cell over the simulations, and compare $\pi_i$ to the distribution of 
 $\pi_i^*$.
 
```{r 8q4_b}
pi_i <- sims %>%
  group_by(Cell) %>%
  summarize(mean_p = mean(pi_star))
sims %>%
  ggplot(aes(x = pi_star, fill = Cell)) +
  geom_histogram() +
  geom_vline(aes(xintercept = pi_i$mean_p[1]), linetype = 2, color = "red") +
  geom_vline(aes(xintercept = pi_i$mean_p[2]), linetype = 2, color = "red") +
  geom_vline(aes(xintercept = pi_i$mean_p[3]), linetype = 2, color = "black") +
  geom_vline(aes(xintercept = pi_i$mean_p[4]), linetype = 2, color = "red") +
  ggtitle("Distribution of Product Probabilities",
    subtitle = "Dotted Lines Indicate Average of Cell Distribution"
  )
```

As constructed, the $\pi_i$ are the average of the $\pi_i^*$ so, naturally, 
these appear in the center of the distributions. What is perhaps more relieving
is that the distributions either have low variance, when they have small 
probabilities of occurring, or are nicely normally distributed when they are,
which, again, makes sense.

5. This exercise uses the WA state crime data for 2004 as the population and the
data for 2003 as the auxiliary variables.

  *  Take a simple random sample of 20 police districts from the state and use 
  all the data from the sampled counties. Estimate the ratio of violent crimes
  to property crimes.
  
```{r 8q5_a}
wa_crime_df <- readxl::read_xlsx("data/WA_crime/1984-2011.xlsx",
  skip = 4
) %>%
  filter(Year %in% c("2003", "2004"), Population > 0) %>%
  mutate(
    murder = `Murder Total`,
    murder_and_crime = `Murder Total` + `Burglary Total`,
    violent_crime = `Violent Crime Total`,
    burglaries = `Burglary Total`,
    property_crime = `Property Crime Total`,
    state_pop = sum(Population),
    County = stringr::str_to_lower(County),
    num_counties = n_distinct(County),
  ) %>%
  group_by(County) %>%
  mutate(num_agencies = n_distinct(Agency)) %>%
  ungroup() %>%
  select(
    Year, County, Agency, Population, murder_and_crime, murder, violent_crime,
    property_crime, burglaries, num_counties, num_agencies
  )

district_sample <- wa_crime_df %>%
  filter(Year == "2004") %>%
  distinct(Agency) %>%
  slice_sample(n = 20) %>%
  pull(Agency)

srs_design <- wa_crime_df %>%
  filter(Year == "2004") %>%
  mutate(fpc = n_distinct(Agency)) %>%
  filter(Agency %in% district_sample) %>%
  select(Year, County, Agency, Population, violent_crime, property_crime, fpc) %>%
  left_join(wa_crime_df %>% filter(Year == "2003") %>%
    select(County, Agency, burglaries, Population) %>%
    rename_if(is.numeric, function(x) str_c(x, "_2003"))) %>%
  as_survey_design(
    ids = "Agency",
    fpc = fpc
  )

srs_design %>%
  summarize(
    survey_ratio(violent_crime, property_crime)
  )
```
  
  * Calibrate the sample in the previous question using population and number of
  burglaries as the auxiliary variables, and estimate the ratio of violent 
  crimes to property crimes.
  
```{r 8q5_b}
srs_calibration <- calibrate(srs_design, ~ burglaries_2003 + ~Population_2003,
  population = 1
)
svyratio(~violent_crime, ~property_crime, srs_calibration)
```

Our point estimate has moved closer to the population ratio, but the variance
has increased.
  
  * The ratio of violent crimes to property crimes in the state in 2003 was 
  $21078 / 290945 = 0.0724$. Define an auxiliary variable 
  `infl = violent - 0.0724 x property`, the influence function for the ratio,
  and use it to calibrate to the state data. Estimate the ratio of violent
  crimes to property crimes.
  
```{r 8q5_c}
srs_design <- update(srs_design,
  infl = violent_crime - 0.0724 * property_crime
)
srs_calibration <- calibrate(srs_design, ~infl,
  population = 1
)
svyratio(~violent_crime, ~property_crime, srs_calibration)
```

Now we see a pretty much spot on estimate and the lowest standard error of them
all.
  
  * Take a simple random sample of 100 police districts as phase one of a 
  two-phase design, and assume that the 2003 crime data are available at phase
  one. Divide the sample into 10 strata with roughly equal total number of 
  burglaries in 2003 and sample two police districts from each stratum for
  phase two. Estimate the total number of murders, and of burglaries, in the 
  state.
  
```{r 8q5_d}
set.seed(35315)
district_sample <- wa_crime_df %>%
  filter(Year == "2004") %>%
  distinct(Agency) %>%
  slice_sample(n = 100) %>%
  pull(Agency)

burglary_quantiles <- wa_crime_df %>%
  filter(Year == "2003", Agency %in% district_sample) %>%
  pull(burglaries) %>%
  quantile(., seq(from = 0, to = 1, length.out = 10))

second_phase_sample <- wa_crime_df %>%
  filter(Year == "2004", Agency %in% district_sample) %>%
  mutate(strata = cut(burglaries, burglary_quantiles,
    include.lowest = TRUE
  )) %>%
  group_by(strata) %>%
  slice_sample(n = 2) %>%
  ungroup() %>%
  pull(Agency)


wa_crime_df %>%
  filter(Year == "2004") %>%
  mutate(
    fpc_one = n_distinct(Agency),
    strata = cut(burglaries, burglary_quantiles, include.lowest = TRUE)
  ) %>%
  filter(Agency %in% district_sample) %>%
  mutate(
    in_second_phase = (Agency %in% second_phase_sample),
    fpc_two = n(),
  ) %>%
  as_survey_twophase(
    id = list(Agency, Agency),
    strata = list(NULL, strata),
    subset = in_second_phase,
    fpc = list(fpc_one, fpc_two)
  ) %>%
  summarize(
    num_burglaries = survey_total(burglaries),
    num_murders = survey_total(murder)
  )
```
  
  * Calibrate the two-phase sample using the auxiliary variable `infl`. Estimate
  the total number of murders, and of burglaries, in the state.
  
```{r 8q5_e}
two_phase_crime_design <- wa_crime_df %>%
  filter(Year == "2004") %>%
  mutate(
    fpc_one = n_distinct(Agency),
    strata = cut(burglaries, burglary_quantiles, include.lowest = TRUE),
    infl = violent_crime - 0.0724 * property_crime,
  ) %>%
  filter(Agency %in% district_sample) %>%
  mutate(
    in_second_phase = (Agency %in% second_phase_sample),
    fpc_two = n(),
  ) %>%
  as_survey_twophase(
    id = list(Agency, Agency),
    strata = list(NULL, strata),
    subset = in_second_phase,
    fpc = list(fpc_one, fpc_two)
  )

total_pop <- wa_crime_df %>%
  filter(Year == "2004") %>%
  summarize(total_pop = sum(Population)) %>%
  pull(total_pop)

calibrate_tp_cd <- calibrate(two_phase_crime_design, ~infl,
  population = total_pop,
  phase = "2"
)
svytotal(~ burglaries + ~murder, design = calibrate_tp_cd)
```

Very different answers, I'm guessing due to my misunderstanding of the 
`population` argument for the `calibrate()` function. Will amend ASAP.


6. What would the efficiency approximation from exercise 5.8 give as the loss of
efficiency from using weights in a case-control design?

TODO(apeterson)
```{r 8q6}
```

# Chapter 9: Missing Data

## Item Non-Response

Lumley opens this chapter by drawing a distinction between item and unit 
non-response. *Item non-response* refers to the case in which partial data
is available from a sampled respondent or observation, but not all. In contrast,
*unit non-response* occurs when no data at all is available from a sampled
respondent or unit of analysis.


# Chapter 10: Causal Inference


# Session Info

<details>

```{r session_info}
DBI::dbDisconnect(db)
sessionInfo()
```

</details>

# References
